---
title: "Advanced Data Manipulation with `dplyr` and `tidyr`"
subtitle: "Parks Canada; Ecological Integrity Monitoring Program"
author: "Andy Teucher"
format: revealjs
knitr:
  opts_chunk: 
    R.options:
      width: 120
      pillar.print_max: 5
      pillar.print_min: 5
    echo: true
---

```{r}
#| include: false
penguins <- dplyr::as_tibble(penguins)
```

## Outline

::: {.columns}
::: {.column width="50%"}

Today:

- `dplyr` fundamentals review
- Column-wise operations
- Two-table verbs (joins)

:::
::: {.column width="50%"}

Next time:

- Window functions
- Data reshaping with `tidyr`

:::
:::

## Data

### Using data from the [Portal Project](https://portal.weecology.org/)

Long-term ecological research site studying the dynamics of desert rodents, plants, ants and weather in Arizona.

Data available from the [GitHub repo](https://github.com/weecology/PortalData) via the [`portalr`](https://github.com/weecology/portalr) package.

## Setup

1. Create a new project in Positron

- Either: 
	- Fork and clone the exercises repository:  
	 `https://github.com/ateucher/pc-data-manipulation/` OR 
	- Run:
	 ```r
	 usethis::use_course("https://github.com/ateucher/pc-data-manipulation/archive/refs/heads/main.zip")
	 ```

2. Open the file: `01-get-data.R`

3. Download the data:

```{r}
#| eval: false
install.packages("portalr")
library(portalr)

download_observations(".")
```

4. Explore the downloaded data in Positron

## Warm-up

Read in the rodent capture data (`PortalData/Rodents/Portal_rodent.csv`). 

1. Use `readr::read_csv()` and assign it to a data frame called `rodents`.
2. Standardize column names to use `snake_case` *(hint: check out the `janitor` package)*

## Review of main `dplyr` operations

- Select columns with `select()`
- Keep rows based on their values with `filter()`
- Create new columns with `mutate()`
- Summarize data with `summarize()`
- Sort rows based on column values with `arrange()`
- "Slice" rows with `slice()`/`slice_*()`

::: {.fragment}
- Grouping data with `group_by()` applies `filter()`, `mutate()`, `summarize()`, and `slice()` by group
:::

## Using `select()`

::: {.columns}
::: {.column width="50%"}

### Select columns with bare names

```{r}
library(dplyr)

penguins |>
  select(species, island, body_mass)
```

:::
::: {.column width="50%"}

### Use `all_of()` or `any_of()` to select columns from a character vector

- `all_of()`: throws an error if any names are not found
- `any_of()`: ignores names that are not found

```{r}
#| output-location: fragment
cols <- c("species", "sex", "bill_len", "bill_dep")
select(penguins, all_of(cols))
```

:::
:::

::: {.question}
[Your turn:]{.color-yellow} Select record_id, id, and species from rodents
:::

## selection helpers

::: {.columns}
::: {.column width="50%"}
### select _specific columns_:

- `everything()`: Matches all variables.
- `last_col()`: Select last variable, possibly with an offset.
- `group_cols()`: Select all grouping columns.

:::
::: {.column width="50%"}

### select columns based on _name patterns_:

- `starts_with()`: Starts with a prefix.
- `ends_with()`: Ends with a suffix.
- `contains()`: Contains a literal string.
- `matches()`: Matches a regular expression.

### select columns based on _data type_:

- `where()`: Select columns based on a predicate function (a function that returns `TRUE` or `FALSE`).

:::
:::

See help with `?select`

::: {.notes}

- `everything()` is useful when you want to move a column to the front or back of the data frame.
- Selection helpers can be combined using `c()`, e.g., `select(df, c(starts_with("temp"), ends_with("date")))`

:::

## Your turn

### Using the `rodents` data.frame:

- Select the `id` column and all of the numeric columns

- Select all columns except the "note" columns (starting with `note`)

- Reorder the columns, moving the last column to the first position, without specifying any column names

## Using `filter()`

To retain only a subset of rows:
```{r}
filter(penguins, species == "Adelie")
```

## Combine multiple `filter()` conditions with `,` or `&` (AND) and `|` (OR):

```{r}
filter(penguins, species == "Adelie", island == "Torgersen")
```

<br>

```{r}
filter(penguins, species == "Adelie" | (species == "Gentoo" & body_mass < 4000))
```

## Using `mutate()`

Create new columns or modify existing columns:
```{r}
mutate(penguins, mass_kg = body_mass / 1000)
```

::: {.fragment}
Create multiple columns at once:

```{r}
mutate(
  penguins,
  mass_kg = body_mass / 1000,
  bill_ratio = bill_len / bill_dep
)
```
:::

## The pipe ( |> )

The pipe operator (`|>`) passes the output of one function as the first argument to the next function.
It allows us to chain together multiple operations in a readable way.

::: {.fragment}
- Helps avoid deeply nested function calls.

```r
filter(select(penguins, species, island, body_mass), body_mass > 4000)
```
:::

::: {.fragment}

- Helps avoid creating many intermediate variables.

```r
selected_data <- select(penguins, species, island, body_mass)
filtered_data <- filter(selected_data, body_mass > 4000)
```
:::

::: {.fragment}

Read it out loud as _"and then"_

```{r}
penguins |> # and then
  select(species, island, body_mass) |> # and then
  filter(body_mass > 4000)
```

:::

## Using `group_by()`

Add grouping attributes that tell other `dplyr` functions to operate by group:

```{r}
penguins |>
  select(species, island, body_mass) |>
  filter(body_mass > 4000) |>
  group_by(species, island)
```

## Using `summarize()`

Creates one summary row per unique combination of groups:

```{r}
penguins |>
  select(species, island, body_mass) |>
  filter(body_mass > 4000) |>
  group_by(species, island) |>
  summarise(sd_mass = sd(body_mass, na.rm = TRUE))
```

## Your turn - pulling it all together

Using the `rodents` data set find the mean hindfoot length per weight of Merriam's Kangaroo Rats (`"DM"`) grouped by `plot` and arranged by thew new hfl per weight column.

## `dplyr` practice

::::: {.columns}
::: {.column width="68%"}

1. Remove records from invalid sampling periods (when `period` is negative). Re-assign the result to the `rodents` data frame.

2. How many individuals of each species were caught in 1995?

3. What date had the highest number of individual rodents caught?

:::

:::: {.column width="30%"}
::: {style="padding-left: 1em; border-left: 1px solid #ccc;"}

**Key columns**

- `id` = individual identifier
- `day`, `month`, `year` = date of capture
- `period` = sampling period
- `species` = species code
- `wgt` = weight (grams)
- `year` = year of capture

:::
::::
:::::

## `dplyr` practice

::::: {.columns}
::: {.column width="68%"}

4. For each capture record, calculate the percent difference in weight from the average weight of that species.

5. Of all individual Ord's Kangaroo Rats (species code "DO") that have been caught more than 5 times, which individual was consistently the biggest? (i.e., has the highest average percent difference in weight from the species' average weight)?

:::

:::: {.column width="30%"}
::: {style="padding-left: 1em; border-left: 1px solid #ccc;"}

**Key columns**

- `id` = individual identifier
- `day`, `month`, `year` = date of capture
- `period` = sampling period
- `species` = species code
- `wgt` = weight (grams)
- `year` = year of capture

:::
::::
:::::

## Column-wise operations

<!-- Start here after dplyr fundamentals -->

- Apply one or more functions to a set of columns in a data frame using `across()`

```r
across(<columns>, <functions>)
```

- Specify columns using [selection helpers](https://tidyselect.r-lib.org/reference/language.html) (e.g., `starts_with()`, `ends_with()`, `contains()`, `where()`, etc.)
- Specify function(s) to apply to selected columns
- Used with `summarize()` & `mutate()`

::: {.fragment}

#### Example: calculate mean of all numeric columns

```{r}
#| eval: false

library(dplyr)

mtcars |>
  group_by(cyl) |>
  summarize(across(where(is.numeric), mean))
```

:::

::: {.question .fragment}
[Your turn:]{.color-yellow} Scale all numeric columns (use `across()`) in `rodents` to have mean 0 and standard deviation 1.

_hint:_ Check out the `scale()` function
:::


::: {.notes}
Selection syntax is the same as in `select()`, i.e., using the same selection helpers

We are passing the function `mean` to `across()`, not calling it (i.e., no parentheses).
Functions in R are objects that can be passed around and used later.
:::

## Column-wise operations

specify multiple functions to apply in a `list()`

<br>

::: {.fragment}

#### Example: calculate mean and sd of all numeric columns

```{r}
#| output-location: fragment
library(dplyr)
mtcars |>
  group_by(cyl) |>
  summarize(
    across(where(is.numeric), list(mean = mean, sd = sd))
  )
```

:::

::: {.resources}

<https://tidyselect.r-lib.org/reference/language.html>

:::

## Column-wise operations

Run this in your R session, what do you get?
```{r}
#| output-location: fragment
library(dplyr)
penguins |>
  summarize(
    across(where(is.numeric), list(mean = mean, sd = sd))
  )
```

<br>

::: {.fragment}

- When we use a function in `across()` it is called with its default arguments
	- `mean()` and `sd()` both have an argument `na.rm` that defaults to `FALSE`
- We can't pass extra arguments to functions inside `across()` directly
- We need to pass a function with the argument values we want "baked in"

:::

::: {.resources}

<https://tidyselect.r-lib.org/reference/language.html>

:::

## Specifying extra arguments

We can define our own helper functions:

```{r}
#| output-location: fragment
library(dplyr)

sd_na <- function(x) {
  sd(x, na.rm = TRUE)
}

mean_na <- function(x) {
  mean(x, na.rm = TRUE)
}

penguins |>
  summarize(
    across(where(is.numeric), list(mean = mean_na, sd = sd_na))
  )
```

## Specifying extra arguments

But if we're doing this only once we can define them in place with an [anonymous function]{.highlight-term}:

```r
\(x) function(x, other_args)
```

- This defines a function "on the fly" with the arguments specified how we want
- The `x` will take the values of each column passed to it by `across()`

```{r}
#| output-location: fragment
library(dplyr)

penguins |>
  summarize(
    across(
      where(is.numeric),
      list(
        mean = \(x) mean(x, na.rm = TRUE),
        sd = \(x) sd(x, na.rm = TRUE)
      )
    )
  )
```


## Your turn

1. Calculate the median of hind-foot length (`hfl`) and weight (`wgt`) for each species in `rodents`, ignoring `NA` values.

## Two-table verbs (joins)

::: {.columns}
::: {.column width="50%"}

![](img/tables-join-1.png){.absolute width=540px left=80px top=225px}

:::

::: {.column width="50%"}

### Mutating joins

- Combine two tables based on common values in one or more columns

### Filtering joins

- Filter rows from one table based on values in another table

::: 
:::

::: {.resources}

<https://r4ds.hadley.nz/joins.html#how-do-joins-work>

:::

## Mutating joins

::: {.columns}
::: {.column width="50%"}

### `left_join()`

- Keeps all rows in the [left]{.highlight-term} table
- Drops rows from the [right]{.highlight-term} table that don't match
- Rows in the [left]{.highlight-term} that don't match get `NA` in the columns from the [right]{.highlight-term} table

:::

::: {.column width="50%"}

![](img/left-join.png)

:::
:::

::: {.resources}

<https://r4ds.hadley.nz/joins.html#how-do-joins-work>

:::

## Mutating joins

::: {.columns}
::: {.column width="50%"}

### `right_join()`

- Keeps all rows in the [right]{.highlight-term} table
- Drops rows from the [left]{.highlight-term} table that don't match
- Rows in the [right]{.highlight-term} table that don't match get `NA` in the columns from the [left]{.highlight-term} table

:::

::: {.column width="50%"}

![](img/right-join.png)

:::
:::

::: {.resources}

<https://r4ds.hadley.nz/joins.html#how-do-joins-work>

:::

## Mutating joins

::: {.columns}
::: {.column width="50%"}

### `inner_join()`

- Keeps all rows in both tables where keys match
- Rows from either table that don't match are dropped

:::
::: {.column width="50%"}

![](img/inner-join.png)

:::
:::

::: {.resources}

<https://r4ds.hadley.nz/joins.html#how-do-joins-work>

:::

## Mutating joins

::: {.columns}
::: {.column width="50%"}

### `full_join()`

- Keeps all rows in both tables
- Values in x and y that don't match get `NA` in the result

:::
::: {.column width="50%"}

![](img/full-join.png)

:::
:::

::: {.resources}

<https://r4ds.hadley.nz/joins.html#how-do-joins-work>

:::

## Join syntax

If don't specify join columns, will join on all common names

- E.g., both tables have columns year, month, day

```r
left_join(x, y)
#> Joining with `by = join_by(year, month, day)`
```

<br>

Better to specify the join columns explicitly

- Both tables have columns column_1 and column_2

```r
left_join(x, y, by = c("column_1", "column_2"))
```


- If the columns to join on have different names in each table

```r
left_join(x, y, by = c("column_in_x" = "column_in_y"))
```

## Your turn

Use a join to add location information to the rodent captures data

- The rodent captures data is in the `PortalData/Rodents/Portal_rodent.csv` file.

- The `SiteandMethods/Portal_UTMCoords.csv` file contains information about the location of each plot

## Filtering joins

::: {.columns}
::: {.column width="50%"}

### `semi_join()`

- Keeps all rows in the [left]{.highlight-term} table where there are matching key values in the [right]{.highlight-term} table
- Does not add any columns

:::

::: {.column width="50%"}

![](img/semi-join.png)

:::
:::


## Filtering joins

::: {.columns}
::: {.column width="50%"}

### `anti_join()`

- Keeps all rows in the [left]{.highlight-term} table where there are not matching values in the [right]{.highlight-term} table
- Does not add any columns

:::

::: {.column width="50%"}

![](img/anti-join.png)

:::
:::

## Your turn

Use a join to find all the captures where the species is a granivore

- The rodent captures data is in the `PortalData/Rodents/Portal_rodent.csv` file
- The `PortalData/Rodents/Portal_rodent_species.csv` file contains information about the species

## More complex joins using `dplyr::join_by()`. 

**Cross joins** create the full cartesian product of two tables

```{r}
#| output-location: column-fragment
library(dplyr)
x <- data.frame(a = 1:3)
y <- data.frame(b = c("x", "y"))
cross_join(x, y)
```

<br>

::: {.fragment}

Inequality joins

```r
left_join(x, y, by = join_by(column_1 >= column_2))
```

:::

<br>

::: {.fragment}

Rolling joins (inequality joins constrained by `closest()`)

```r
left_join(
    x, y, 
    by = join_by(id, closest(capture_date >= survey_start_date))
)
```

Rolling joins are good for finding things like "the most recent rainy day before a survey date"

:::


::: {.notes}
I haven't found a good reason to use inequality joins, but they are a necessary 
precursor to rolling joins, which are very useful.
:::


## Overlap joins

::: {.columns}
::: {.column width="50%"}

```r
between(x, y_1, y_2)
within(x_1, x_2, y_1, y_2)
overlaps(x_1, x_2, y_1, y_2)
```

:::
::: {.column width="50%"}

```{.plaintext .cell-output-tall}
between(x, y_1, y_2):

  y_1 [════════════════════] y_2
         •
         x


within(x_1, x_2, y_1, y_2):

  y_1 [════════════════════] y_2
         [═════]
       x_1     x_2


overlaps(x_1, x_2, y_1, y_2):

  y_1 [════════════════════] y_2
                   [═══════════════] 
                 x_1             x_2
```
:::
:::

::: {.resources}

<https://dplyr.tidyverse.org/reference/join_by.html#join-types>

:::

## Your turn

Using the rodent trapping data and the plant census dates data, join the two 
datasets to find out which plant census (year and season) each rodent capture 
is associated with.

Starting code:

```r
library(dplyr)
library(readr)
library(lubridate)

plant_census_dates <- read_csv(
  "PortalData/Plants/Portal_plant_census_dates.csv",
  na = c("unknown", "none")
)

rodent_trapping <- read_csv("PortalData/Rodents/Portal_rodent_trapping.csv")
```

* Hint: use an overlap join with `between()`

# Tidying data with `tidyr`

> “Happy families are all alike; every unhappy family is unhappy in its own way.”

— Leo Tolstoy

<br>

> “Tidy datasets are all alike, but every messy dataset is messy in its own way.”

— Hadley Wickham

## What is tidy data?

1. Each variable is a column; each column is a variable.
2. Each observation is a row; each row is an observation.
3. Each value is a cell; each cell is a single value.

![](img/tidy-data-r4ds.png)

## Wide vs. long (tidy) data

- Wide data often has "data" stored in the column names
  - Example: dates, treatment groups, measurement types

::: {.columns}
::: {.column width="49%"}

```{r}
#| echo: false
library(tibble)

knitr::kable(tribble(
  ~subject, ~treatment_A, ~treatment_B,
  1,         5,           7,
  2,         6,           8
))
```

<br>

::: {.fragment}

```{r}
#| echo: false
knitr::kable(tribble(
  ~subject , ~treatment , ~value ,
         1 , "A"        ,      5 ,
         1 , "B"        ,      7 ,
         2 , "A"        ,      6 ,
         2 , "B"        ,      8
))
```

:::
::: 

{{< column-divider >}}

::: {.column width="49%"}
::: {.fragment}

```{r}
#| echo: false
#| output-location: fragment

knitr::kable(tribble(
  ~id , ~"20250101" , ~"20250201" ,
    1 , 150 ,         165 ,
    2 , 125 ,         118
))
```

- Dates are stored in the column names
- Values are masses (in grams).

:::

<br>

::: {.fragment}

```{r}
#| echo: false
knitr::kable(tribble(
  ~id, ~date,       ~mass,
  1,   "2025-01-01", 150,
  1,   "2025-02-01", 165,
  2,   "2025-01-01", 125,
  2,   "2025-02-01", 118
))
```

:::
:::
::::

::: {.notes}

- Each row has more than one observation
- Variables split across multiple columns
- Second example - we hopefully have metadata that tells us that the values are masses (in grams)

:::

## `tidyr::pivot_longer()`

- Reshape data from wide to long format

```r
pivot_longer(
  data,
  cols, # The columns to pivot into longer format. Use tidyselect helpers
  names_to, # The name(s) of the new column(s) that will contain the former column names
  values_to # The name of the new column that will contain the values from the pivoted columns
)
```



# string manipulation and regular expressions
