{
  "hash": "8915d69cff3913c3b57721b818b529b8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"String Manipulation with Regular Expressions\"\nsubtitle: \"Parks Canada; Ecological Integrity Monitoring Program\"\nauthor: \"Andy Teucher\"\nformat: revealjs\nknitr:\n  opts_chunk: \n    R.options:\n      width: 110\n      pillar.print_max: 5\n      pillar.print_min: 5\n    echo: true\n---\n\n\n\n## Why regular expressions?\n\nWorking with text data is common in data science:\n\n::: {.incremental}\n- **File names**: Extract dates, site IDs, or plot numbers\n- **Data cleaning**: Standardize species codes, fix formatting\n- **Data validation**: Check if values match expected patterns\n:::\n\n::: {.fragment}\n**Regular expressions** (regex) are a powerful pattern-matching language for working with text.\n:::\n\n## The `stringr` package\n\nPart of the tidyverse, `stringr` makes working with strings consistent and easy.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n```\n:::\n\n\n::: {.incremental}\nAll `stringr` functions:\n\n- Start with `str_`\n- Take the string as the first argument (pipe-friendly!)\n- Use regular expressions for pattern matching\n:::\n\n## Basic string operations\n\nBefore regex, let's see simple `stringr` functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsites <- c(\n  \"Banff National Park\",\n  \"Jasper National Park\",\n  \"Yoho National Park\",\n  \"Kootenay National Park\"\n)\n```\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_length(sites) # Count characters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19 20 18 22\n```\n\n\n:::\n:::\n\n\n:::\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_upper(sites) # Convert to uppercase\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"BANFF NATIONAL PARK\"    \"JASPER NATIONAL PARK\"   \"YOHO NATIONAL PARK\"     \"KOOTENAY NATIONAL PARK\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(sites, \"Banff\") # Does it contain \"Banff\"?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n## Literal pattern matching\n\nThe simplest regex: match exact text\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- c(\n  \"2024-08-12_site-1_plot-data.csv\",\n  \"2024-08-12_site-2_plot-data.csv\",\n  \"2024-09-15_site-1_plot-data.csv\"\n)\n```\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Which files are from site-1?\nstr_detect(files, \"site-1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract just the matching files\nsite1_files <- str_subset(files, \"site-1\")\nsite1_files\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-08-12_site-1_plot-data.csv\" \"2024-09-15_site-1_plot-data.csv\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## The dot (`.`): match any character\n\n`.` matches *any single* character\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- c(\"PIEN\", \"PICO\", \"ABLA\", \"POTR\")\n\n# Match PI followed by any two characters\nstr_detect(species, \"PI..\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\n# What does it match?\nstr_subset(species, \"PI..\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PIEN\" \"PICO\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Character classes: `[]`\n\nMatch **one** of several characters\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncodes <- c(\"Plot1\", \"Plot2\", \"Plot3\", \"PlotA\", \"PlotB\")\n```\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match Plot followed by a digit\nstr_subset(codes, \"Plot[123]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Plot1\" \"Plot2\" \"Plot3\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match Plot followed by a letter\nstr_subset(codes, \"Plot[AB]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PlotA\" \"PlotB\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Character ranges\n\nUse `-` inside `[ ]` for ranges:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match any digit\nstr_subset(codes, \"Plot[0-9]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Plot1\" \"Plot2\" \"Plot3\"\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match any lowercase letter\nstr_subset(codes, \"Plot[a-z]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match any letter (upper or lower)\nstr_subset(codes, \"Plot[A-Za-z]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PlotA\" \"PlotB\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Negating character classes: `[^ ]`\n\n`^` inside `[ ]` means \"NOT these characters\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeasurements <- c(\"temp_C\", \"temp_F\", \"precip_mm\", \"wind_kph\")\n\n# Match measurements NOT in Celsius\nstr_subset(measurements, \"temp_[^C]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"temp_F\"\n```\n\n\n:::\n:::\n\n\n## Quantifiers: how many times?\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n- `?` - 0 or 1 time (optional)\n- `*` - 0 or more times\n- `+` - 1 or more times\n- `{n}` - exactly n times\n- `{n,m}` - between n and m times\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\nQuantifiers apply to the preceding element.\n\n- `a+` matches one or more 'a's\n- `[0-9]{2}` matches exactly two digits\n- `-?` matches an optional hyphen\n- `8{3,4}` matches the number `8` repeated 3 or 4 times (i.e., `888` or `8888`)\n\n:::\n:::\n:::\n\n## Quantifiers in action\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- c(\"2024-8-12\", \"2024-08-12\", \"2024-8-1\", \"24-08-12\", \"20240523\")\n```\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match 4-digit year 2024 and 1 or 2 digits for month\nstr_detect(dates, \"2024-[0-9]{1,2}-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n:::\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match exactly 2 digits for month (more strict)\nstr_detect(dates, \"2024-[0-9]{2}-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n:::\n::: {.fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match dates regardless of if they use `-` as a separator\nstr_detect(dates, \"[0-9]{4}-?[0-9]{1,2}-?[0-9]{1,2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n## Anchors: position matters\n\n- `^` - start of string\n- `$` - end of string\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilenames <- c(\"data.csv\", \"plot-data.csv\", \"data-plot.csv\")\n\n# Files that START with \"data\"\nstr_subset(filenames, \"^data\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.csv\"      \"data-plot.csv\"\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Files that END with \".csv\"\nstr_subset(filenames, \"\\\\.csv$\") # \\\\ escapes the .\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.csv\"      \"plot-data.csv\" \"data-plot.csv\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Special characters need escaping\n\nSome characters have special meaning: `. * + ? [ ] { } ( ) ^ $ | \\`\n\nTo match them literally, escape with `\\\\`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprices <- c(\"$12.99\", \"$5.00\", \"12.99\", \"free\")\n\n# Match prices with dollar sign\nstr_subset(prices, \"\\\\$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"$12.99\" \"$5.00\" \n```\n\n\n:::\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Match prices with decimal point\nstr_subset(prices, \"\\\\.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"$12.99\" \"$5.00\"  \"12.99\" \n```\n\n\n:::\n:::\n\n\n:::\n\n## Shorthand character classes\n\nConvenient shortcuts:\n\n- `\\\\d` - any digit (same as `[0-9]`)\n- `\\\\s` - whitespace (space, tab, newline)\n- `\\\\w` - word character (letter, digit, underscore)\n\n::: {.fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\nsite_codes <- c(\"SITE_001\", \"SITE 002\", \"SITE-003\")\n\n# Match SITE followed by any character, followed by a digit\nstr_subset(site_codes, \"SITE.\\\\d+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SITE_001\" \"SITE 002\" \"SITE-003\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Extracting matches: `str_extract()`\n\nGet the actual matching text:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_files <- c(\"2024-08-12_banff_temp.csv\", \"2024-09-15_jasper_precip.csv\")\n\n# Extract the dates\nstr_extract(data_files, \"\\\\d{4}-\\\\d{2}-\\\\d{2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-08-12\" \"2024-09-15\"\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the park names\nstr_extract(data_files, \"[a-z]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"banff\"  \"jasper\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Capturing groups: `( )`\n\nParentheses create groups you can extract separately:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- c(\"2024-08-12\", \"2024-09-15\", \"2023-12-31\")\n\n# Extract year, month, day separately\nstr_match(dates, \"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]         [,2]   [,3] [,4]\n[1,] \"2024-08-12\" \"2024\" \"08\" \"12\"\n[2,] \"2024-09-15\" \"2024\" \"09\" \"15\"\n[3,] \"2023-12-31\" \"2023\" \"12\" \"31\"\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\nFirst column is the full match, then each group.\n:::\n\n<br>\n\n::: {.fragment}\n\n### Use `str_extract()` and specify `group` to just get the months\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract(dates, \"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\", group = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"08\" \"09\" \"12\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Replacing text: `str_replace()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessy_codes <- c(\"SITE_001\", \"SITE-002\", \"SITE_003\", \"PLOT_004\", \"PLOT-005\")\n\n# Replace hyphens with underscores\nstr_replace(messy_codes, \"-\", \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SITE_001\" \"SITE_002\" \"SITE_003\" \"PLOT_004\" \"PLOT_005\"\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace \"SITE\" with \"PLOT\"\nstr_replace(messy_codes, \"SITE\", \"PLOT\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PLOT_001\" \"PLOT-002\" \"PLOT_003\" \"PLOT_004\" \"PLOT-005\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine them with pipes\nclean_codes <- str_replace(messy_codes, \"-\", \"_\") |>\n  str_replace(\"SITE\", \"PLOT\")\nclean_codes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PLOT_001\" \"PLOT_002\" \"PLOT_003\" \"PLOT_004\" \"PLOT_005\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Replace all occurrences: `str_replace_all()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext <- \"The quick brown fox jumps over the lazy dog\"\n\n# Replace first \"the\" (case-sensitive)\nstr_replace(text, \"the\", \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The quick brown fox jumps over a lazy dog\"\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace all spaces with underscores\nstr_replace_all(text, \" \", \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The_quick_brown_fox_jumps_over_the_lazy_dog\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Practical regex workflow\n\n::: {.incremental}\n1. **Start simple**: Match literal text first\n2. **Test iteratively**: Use `str_detect()` and `str_subset()` to verify\n3. **Build complexity**: Add character classes, quantifiers\n4. **Extract or replace**: Use `str_extract()` or `str_replace()`\n5. **Validate**: Check edge cases\n:::\n\n::: {.fragment}\n**Pro tip**: Use [regex101.com](https://regex101.com) to test and debug patterns!\n:::\n\n## Your turn: Exercise 1 {.exercise}\n\nYou have these file names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- c(\n  \"2024-08-12_site1_plot-A_data.csv\",\n  \"2024-08-12_site2_plot-B_data.csv\",\n  \"2024-09-15_site1_plot-C_data.csv\",\n  \"2023-12-31_site3_plot-A_data.csv\"\n)\n```\n:::\n\n\n1. Extract all dates (YYYY-MM-DD format)\n2. Find files from site1\n3. Extract the plot letter (A, B, or C)\n\n::: {.notes}\nGive participants 5 minutes to work on this\n:::\n\n## Solution: Exercise 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Extract dates\nstr_extract(files, \"^\\\\d{4}-\\\\d{2}-\\\\d{2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-08-12\" \"2024-08-12\" \"2024-09-15\" \"2023-12-31\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. Find files from site1\nstr_subset(files, \"site1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-08-12_site1_plot-A_data.csv\" \"2024-09-15_site1_plot-C_data.csv\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# 3. Extract plot letter\nstr_extract(files, \"plot-[A-Z]\") |>\n  str_extract(\"[A-Z]$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\" \"A\"\n```\n\n\n:::\n:::\n\n\n## Your turn: Exercise 2 {.exercise}\n\nYou have messy species codes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- c(\n  \"PIEN (Engelmann Spruce)\",\n  \"PICO   Lodgepole Pine\",\n  \"ABLA - Subalpine Fir\",\n  \"POTR/Trembling Aspen\"\n)\n```\n:::\n\n\n1. Extract just the 4-letter species codes\n2. Replace all separators (spaces, -, /, parentheses) with a single space\n3. Create clean format: \"CODE: Common Name\"\n\nHint: Check out `str_squish()` to remove extra whitespace!\n\n::: {.notes}\nGive participants 5-7 minutes for this one\n:::\n\n## Solution: Exercise 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Extract 4-letter codes\nstr_extract(species, \"^[A-Z]{4}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PIEN\" \"PICO\" \"ABLA\" \"POTR\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. Replace separators with space\ncleaned <- str_replace_all(species, \"[()/-]\", \" \") |>\n  str_squish() # Remove extra whitespace\n\n# 3. Create clean format\ncodes <- str_extract(cleaned, \"^[A-Z]{4}\")\nnames <- str_replace_all(cleaned, \"^[A-Z]{4} \", \"\")\npaste0(codes, \": \", names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PIEN: Engelmann Spruce\" \"PICO: Lodgepole Pine\"   \"ABLA: Subalpine Fir\"    \"POTR: Trembling Aspen\" \n```\n\n\n:::\n:::\n\n\n## Resources\n\n- **`stringr` cheatsheet**: [posit.co/resources/cheatsheets](https://posit.co/resources/cheatsheets/)\n- **Interactive testing**: [regex101.com](https://regex101.com)\n- **Book chapter**: [R for Data Science - Strings](https://r4ds.hadley.nz/strings)\n- **Practice**: [regexone.com](https://regexone.com)\n\n::: {.fragment}\n**Remember**: Regular expressions are a skill built through practice. Start simple and build complexity as needed!\n:::\n\n## Key takeaways\n\n::: {.incremental}\n1. `stringr` functions are consistent and pipe-friendly\n2. Start with literal matches, add complexity iteratively\n3. Common patterns: `.` (any), `[abc]` (one of), `+/*/?/{}` (quantifiers)\n4. Use `\\\\` to escape (match) special characters\n5. Test frequently with `str_detect()` and `str_subset()`\n6. Anchors (`^`, `$`) and groups `()` give you control\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}