{
  "hash": "68a303235bfee9ae365e9d8dc8234842",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Programming with R: Functions\"\nsubtitle: \"Parks Canada; Ecological Integrity Monitoring Program\"\nauthor: \"Andy Teucher\"\nformat: revealjs\nknitr:\n  opts_chunk: \n    R.options:\n      width: 110\n      pillar.print_max: 5\n      pillar.print_min: 5\n    echo: true\n---\n\n\n\n## Outline\n\n- Motivation\n- Fundamentals of functions\n\n## Learning objectives\n\n-   explain the rationale for writing functions\n-   write vector functions\n    -   that take a vector as input and output a vector\n    -   that take a vector as input and output a single value\n-   specify defaults for function arguments\n-   write functions that take dataframes as input and output a dataframe\n\n## Why write functions?\n\n- Make code easier to read and understand\n- Make code shorter\n- Make code less error-prone\n- Make code reusable\n\n::: {.notes}\n\nYou can give a function an evocative name that makes your code easier to understand.\n\nAs requirements change, you only need to update code in one place, instead of many.\n\nYou eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).\n\nIt makes it easier to reuse work from project-to-project, increasing your productivity over time.\n\n:::\n\n## Example: Penguins\n\nWe have several measurements:\n\n-   `bill_len`\n-   `bill_dep`\n-   `flipper_len`\n-   `body_mass`\n\nThese are on very different scales\n\n## \n\n\n::: {.cell layout-ncol=\"2\"}\n::: {.cell-output-display}\n![](programming-functions_files/figure-revealjs/unnamed-chunk-1-1.png){width=960}\n:::\n\n::: {.cell-output-display}\n![](programming-functions_files/figure-revealjs/unnamed-chunk-1-2.png){width=960}\n:::\n\n::: {.cell-output-display}\n![](programming-functions_files/figure-revealjs/unnamed-chunk-1-3.png){width=960}\n:::\n\n::: {.cell-output-display}\n![](programming-functions_files/figure-revealjs/unnamed-chunk-1-4.png){width=960}\n:::\n:::\n\n\n## Example\n\n-   difficult to plot on same axis or determine what value is large for\n\t\tthat variable\n\n-   A common solution is to apply a $z$ score transformation to each\n\t\tvariable.\n\n-   Normalises the values to have a mean of 0 and a standard deviation\n\t\tof 1\n\n$$z = \\frac{x - \\bar{x}}{s.d.}$$\n\n## Apply transformation\n\nWe can apply the same transformation to each variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- penguins |>\n  mutate(\n    z_bill_len = (bill_len - mean(bill_len, na.rm = TRUE)) /\n      sd(bill_len, na.rm = TRUE),\n    z_bill_dep = (bill_dep - mean(bill_len, na.rm = TRUE)) /\n      sd(bill_dep, na.rm = TRUE),\n    z_flipper_len = (flipper_len - mean(flipper_len, na.rm = TRUE)) /\n      sd(flipper_len, na.rm = TRUE),\n    z_body_mass = (body_mass - mean(body_mass, na.rm = TRUE)) /\n      sd(body_mass, na.rm = TRUE)\n  )\n```\n:::\n\n\n## Long, unclear\n\n`(bill_len - mean(bill_len, na.rm = TRUE)) / sd(bill_len, na.rm = TRUE)`\n\n-   Quite a lot of code\n-   Difficult to glance at and determine what the transformation is\n\nHow to shorten and make more clear?\n\n## Coping and pasting\n\n-   Is error prone\n-   Did anyone catch my mistake in the example?\n\n## What is a function?\n\nA named object that:\n\n1. Takes inputs (arguments)\n2. Performs a specific task\n3. Returns outputs (results)\n\n## Vector functions\n\n-   take one or more vectors as input\n-   output same length as input\n-   work well in `mutate()`\n-   appropriate for the *z*-transformation example\n\n## Parts of a function\n\nTo turn your code into a function you need:\n\n-   a name\n-   the arguments - (the pieces that vary)\n-   the body (the code that does the thing)\n\n. . .\n\n```r\nname <- function(arguments) {\n  code body\n}\n```\n\n![](img/carpentries-f-to-c.png)\n\n## Function name\n\n::: {.incremental}\n- Use a verb\n- Difficulty in naming? Maybe this should this be two or three functions?\n- What should we call the function we write to do a $z$ score transformation?\n:::\n\n## Arguments\n\n-   the input vector\n\n-   additional arguments\n\nNaming conventions\n\n-   x for the vector input\n\n``` r\nname <- function(x) {\n  body does things with x\n}\n```\n\n## Return value\n\n::: {.columns}\n\n::: {.column width=\"48%\"}\n\n- Output - what the function _returns_ to the user\n- By default, the last expression evaluated is returned\n- Using explicit `return()` is optional but not usually done\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"50%\"}\n\n### explicit return statement\n\n```r\nfarenheit_to_celsius <- function(f) {\n  celsius <- (f - 32) * 5 / 9\n  return(celsius)\n}\n```\n\\\n\n### implicit return of last named object\n\n```r\nfarenheit_to_celsius <- function(f) {\n  celsius <- (f - 32) * 5 / 9\n  celsius\n}\n```\n\\\n\n### implicit return of last expression\n\n```r\nfarenheit_to_celsius <- function(f) {\n  (f - 32) * 5 / 9\n}\n```\n\n:::\n\n:::\n\n## Functions should be **\"pure\"**\n\n-   Should not depend on external state (e.g., global variables)\n-   Should not have side effects (e.g., modifying global variables, printing to console, plotting, etc.)\n-   Given the same inputs, should always return the same outputs\n\n::: {.columns}\n::: {.column width=\"49%\"}\n\n### Pure\n\n``` r\nadd_one <- function(x) {\n  x + 1\n}\n```\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n### Impure\n\n```r\ny <- 10\n\nadd_y <- function(x) {\n  x + y\n}\n\nadd_to_global <- function(x) {\n  y <<- x + 1\n}\n```\n\n:::\n:::\n\n## Example\n\n$$z = \\frac{x - \\bar{x}}{s.d.}$$\n\n``` r\npenguins <- penguins |>\n  mutate(\n    z_bill_len = (bill_len - mean(bill_len, na.rm = TRUE)) / sd(bill_len, na.rm = TRUE),\n    z_bill_dep = (bill_dep - mean(bill_dep, na.rm = TRUE)) / sd(bill_dep, na.rm = TRUE),\n    z_flipper_len = (flipper_len - mean(flipper_len, na.rm = TRUE)) / sd(flipper_len, na.rm = TRUE),\n    z_body_mass = (body_mass - mean(body_mass, na.rm = TRUE)) / sd(body_mass, na.rm = TRUE)\n  )\n```\n\n## Example\n\nIdentify the arguments: the things that vary across calls\n\n``` r\n(bill_len    - mean(bill_len,    na.rm = TRUE)) / sd(bill_len,    na.rm = TRUE)\n(bill_dep    - mean(bill_dep,    na.rm = TRUE)) / sd(bill_dep,    na.rm = TRUE)\n(flipper_len - mean(flipper_len, na.rm = TRUE)) / sd(flipper_len, na.rm = TRUE)\n(body_mass   - mean(body_mass,   na.rm = TRUE)) / sd(body_mass,   na.rm = TRUE)\n```\n\n\\\n\n. . .\n\n``` r\n(ðŸŸ§ - mean(ðŸŸ§, na.rm = TRUE)) / sd(ðŸŸ§, na.rm = TRUE)\n(ðŸŸ§ - mean(ðŸŸ§, na.rm = TRUE)) / sd(ðŸŸ§, na.rm = TRUE)\n(ðŸŸ§ - mean(ðŸŸ§, na.rm = TRUE)) / sd(ðŸŸ§, na.rm = TRUE)\n(ðŸŸ§ - mean(ðŸŸ§, na.rm = TRUE)) / sd(ðŸŸ§, na.rm = TRUE)\n```\n\nðŸŸ§ is x\n\n## Example\n\nPut into the template\n\n``` r\nname <- function(x) {\n  body does things with x\n}\n```\n\n\\\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_z <- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n```\n:::\n\n\n## Apply\n\nRewrite the call to `mutate()` as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins <- penguins |>\n  mutate(\n    z_bill_len = to_z(bill_len),\n    z_bill_dep = to_z(bill_dep),\n    z_flipper_len = to_z(flipper_len),\n    z_body_mass = to_z(body_mass)\n  )\n```\n:::\n\n\n. . .\n\nMuch shorter, much more clear.\n\n## A modification\n\n`mean()` has a `trim` argument: `mean(x, trim = 0, na.rm = FALSE, ...)`\n\n*the fraction (0 to 0.5) of observations to be trimmed from each end of\nx before the mean is computed.*\n\n. . .\n\nSuppose we want to specify the *middle* proportion left rather than the\nproportion trimmed from each end.\n\n## A modification\n\n-   A value of 0.1 for `trim` trims 0.1 from each end leaving 0.8 in the\n    middle\n\n-   trim = (1 - middle)/2\n\n![Trim is the proportion trimmed off each end; middle is what's \nleft](img/vector-functions-trim.png){fig-alt=\"schematic of trim and middle demonstrating that trim = (1 - middle)/2\"}\n\n## Add an argument\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_z <- function(x, middle) {\n  trim = (1 - middle) / 2\n  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)\n}\n```\n:::\n\n\n## Try it out\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_z(penguins$bill_len, middle = 0.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] -0.92838057 -0.85511491 -0.70858359          NA -1.36797452 -0.89174774 -0.96501340 -0.91006415\n  [9] -1.84420131 -0.39720454 -1.16649396 -1.16649396 -0.56205227 -1.01996264 -1.75261923 -1.38629094\n [17] -1.00164623 -0.30562246 -1.78925206  0.33545205 -1.16649396 -1.18481038 -1.51450584 -1.09322830\n [25] -0.98332981 -1.62440433 -0.65363435 -0.67195076 -1.14817755 -0.67195076 -0.85511491 -1.27639245\n [33] -0.85511491 -0.59868510 -1.42292377 -0.91006415 -0.98332981 -0.36057171 -1.20312679 -0.80016566\n [41] -1.40460735 -0.61700152 -1.49618943 -0.01255983 -1.31302528 -0.83679849 -0.56205227 -1.22144320\n [49] -1.49618943 -0.34225529 -0.83679849 -0.74521642 -1.67935358 -0.39720454 -1.77093565 -0.50710303\n [57] -0.94669698 -0.65363435 -1.40460735 -1.20312679 -1.55113867 -0.52541944 -1.20312679 -0.56205227\n [65] -1.42292377 -0.47047020 -1.58777150 -0.56205227 -1.51450584 -0.43383737 -1.95409980 -0.81848208\n [73] -0.83679849  0.29881922 -1.58777150 -0.25067322 -0.59868510 -1.27639245 -1.45955660 -0.37888812\n [81] -1.75261923 -0.23235681 -1.36797452 -1.66103716 -1.25807603 -0.52541944 -1.44124018 -1.33134169\n [89] -1.07491189 -0.96501340 -1.55113867 -0.56205227 -1.86251772 -0.83679849 -1.45955660 -0.61700152\n [97] -1.11154472 -0.70858359 -2.02736546 -0.17740756 -1.67935358 -0.58036869 -1.18481038 -1.16649396\n[105] -1.14817755 -0.81848208 -1.01996264 -1.09322830 -1.11154472 -0.17740756 -1.11154472  0.26218639\n[113] -0.81848208 -0.36057171 -0.83679849 -0.26898963 -1.01996264 -1.25807603 -1.55113867 -0.56205227\n[121] -1.45955660 -1.18481038 -0.72690000 -0.50710303 -1.64272075 -0.65363435 -0.98332981 -0.48878661\n[129] -0.94669698 -0.01255983 -1.03827906 -0.19572398 -1.34965811 -1.22144320 -1.11154472 -0.56205227\n[137] -1.56945509 -0.72690000 -1.31302528 -0.81848208 -0.72690000 -0.65363435 -2.21052960 -0.63531793\n[145] -1.25807603 -0.94669698 -0.91006415 -1.38629094 -1.49618943 -1.16649396 -1.49618943 -0.48878661\n[153]  0.35376847  1.06810865  0.82999525  1.06810865  0.62851469  0.42703413  0.22555357  0.46366696\n[161] -0.15909115  0.48198337 -0.59868510  0.88494450  0.24386998  0.77504601  0.29881922  0.93989374\n[169] -0.39720454  0.92157733  0.37208488  0.82999525  1.10474148  0.17060432  0.42703413  0.39040130\n[177] -0.23235681  0.35376847  0.06070583  0.66514752  0.73841318  1.06810865  0.57356545 -0.25067322\n[185]  0.17060432  2.82648447  0.90326091  0.77504601 -0.28730605  0.04238942 -0.03087624  0.82999525\n[193] -0.26898963  0.99484299  0.20723715  0.99484299  1.15969072 -0.10414190  0.24386998  1.15969072\n[201]  0.13397149  0.18892074  0.44535054  0.79336242  0.17060432  1.08642506  0.42703413  0.15228791\n[209] -0.06750907  0.24386998 -0.17740756  1.14137431  0.20723715  0.37208488  0.28050281  1.85571448\n[217]  0.29881922  1.03147582  0.37208488  0.97652657 -0.12245832  1.19632355  0.64683111  0.40871771\n[225]  0.73841318  0.42703413  0.40871771  0.81167884  0.61019828  1.26958921  0.18892074  0.18892074\n[233]  0.90326091  1.52601902  0.59188186  1.06810865  0.13397149  1.21463997 -0.14077473  1.30622204\n[241]  0.61019828  1.45275336  0.61019828  1.47106977  0.24386998  0.97652657  0.06070583  1.21463997\n[249]  0.95821016  0.50029979  0.77504601  1.26958921  0.79336242  2.14877712  0.55524903  0.90326091\n[257]  0.57356545  0.48198337 -0.45215378  1.69086675 -0.15909115  0.72009677  1.15969072  1.03147582\n[265] -0.12245832  1.34285487  0.37208488  2.00224580  0.06070583  0.84831167  0.55524903          NA\n[273]  0.48198337  1.14137431  0.18892074  1.04979223  0.42703413  1.06810865  1.30622204  0.22555357\n[281]  1.56265185  0.18892074  0.35376847  1.30622204  0.33545205  1.30622204  0.44535054  1.37948770\n[289]  0.51861620  1.43443694  0.31713564  1.15969072  1.12305789  2.53342183  0.40871771  0.92157733\n[297] -0.32393888  0.79336242 -0.17740756  1.17800714  0.46366696  1.43443694  1.15969072  0.97652657\n[305]  0.40871771  1.58096826 -0.59868510  1.83739807 -0.30562246  1.25127279  1.01315940  0.61019828\n[313]  0.62851469  1.43443694  0.50029979  1.70918316  0.88494450  0.37208488  1.23295638  0.24386998\n[321]  1.23295638  1.21463997  1.08642506  0.88494450  1.34285487  1.03147582  0.72009677  1.32453845\n[329]  0.28050281  1.19632355 -0.30562246  1.47106977  0.18892074  0.93989374  1.10474148  0.26218639\n[337]  1.41612053  0.48198337  0.28050281  2.13046071 -0.12245832  0.99484299  1.21463997  1.10474148\n```\n\n\n:::\n:::\n\n\n## But what if we forget?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_z(penguins$bill_len)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in to_z(penguins$bill_len): argument \"middle\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n## Give a default\n\nGive defaults whenever possible:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_z <- function(x, middle = 1) {\n  trim = (1 - middle) / 2\n  (x - mean(x, na.rm = TRUE, trim = trim)) / sd(x, na.rm = TRUE)\n}\n```\n:::\n\n\n## Try it out\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_z(penguins$bill_len)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] -0.88320467 -0.80993901 -0.66340769          NA -1.32279862 -0.84657184 -0.91983750 -0.86488825\n  [9] -1.79902541 -0.35202864 -1.12131806 -1.12131806 -0.51687637 -0.97478674 -1.70744334 -1.34111504\n [17] -0.95647033 -0.26044656 -1.74407616  0.38062795 -1.12131806 -1.13963448 -1.46932994 -1.04805240\n [25] -0.93815391 -1.57922843 -0.60845845 -0.62677486 -1.10300165 -0.62677486 -0.80993901 -1.23121655\n [33] -0.80993901 -0.55350920 -1.37774787 -0.86488825 -0.93815391 -0.31539581 -1.15795089 -0.75498976\n [41] -1.35943145 -0.57182562 -1.45101353  0.03261607 -1.26784938 -0.79162259 -0.51687637 -1.17626731\n [49] -1.45101353 -0.29707939 -0.79162259 -0.70004052 -1.63417768 -0.35202864 -1.72575975 -0.46192713\n [57] -0.90152108 -0.60845845 -1.35943145 -1.15795089 -1.50596277 -0.48024354 -1.15795089 -0.51687637\n [65] -1.37774787 -0.42529430 -1.54259560 -0.51687637 -1.46932994 -0.38866147 -1.90892390 -0.77330618\n [73] -0.79162259  0.34399512 -1.54259560 -0.20549732 -0.55350920 -1.23121655 -1.41438070 -0.33371222\n [81] -1.70744334 -0.18718091 -1.32279862 -1.61586126 -1.21290014 -0.48024354 -1.39606428 -1.28616579\n [89] -1.02973599 -0.91983750 -1.50596277 -0.51687637 -1.81734182 -0.79162259 -1.41438070 -0.57182562\n [97] -1.06636882 -0.66340769 -1.98218956 -0.13223166 -1.63417768 -0.53519279 -1.13963448 -1.12131806\n[105] -1.10300165 -0.77330618 -0.97478674 -1.04805240 -1.06636882 -0.13223166 -1.06636882  0.30736229\n[113] -0.77330618 -0.31539581 -0.79162259 -0.22381374 -0.97478674 -1.21290014 -1.50596277 -0.51687637\n[121] -1.41438070 -1.13963448 -0.68172411 -0.46192713 -1.59754485 -0.60845845 -0.93815391 -0.44361071\n[129] -0.90152108  0.03261607 -0.99310316 -0.15054808 -1.30448221 -1.17626731 -1.06636882 -0.51687637\n[137] -1.52427919 -0.68172411 -1.26784938 -0.77330618 -0.68172411 -0.60845845 -2.16535371 -0.59014203\n[145] -1.21290014 -0.90152108 -0.86488825 -1.34111504 -1.45101353 -1.12131806 -1.45101353 -0.44361071\n[153]  0.39894437  1.11328455  0.87517115  1.11328455  0.67369059  0.47221003  0.27072946  0.50884286\n[161] -0.11391525  0.52715927 -0.55350920  0.93012040  0.28904588  0.82022191  0.34399512  0.98506964\n[169] -0.35202864  0.96675323  0.41726078  0.87517115  1.14991738  0.21578022  0.47221003  0.43557720\n[177] -0.18718091  0.39894437  0.10588173  0.71032342  0.78358908  1.11328455  0.61874135 -0.20549732\n[185]  0.21578022  2.87166037  0.94843681  0.82022191 -0.24213015  0.08756532  0.01429966  0.87517115\n[193] -0.22381374  1.04001889  0.25241305  1.04001889  1.20486662 -0.05896600  0.28904588  1.20486662\n[201]  0.17914739  0.23409663  0.49052644  0.83853832  0.21578022  1.13160096  0.47221003  0.19746381\n[209] -0.02233317  0.28904588 -0.13223166  1.18655021  0.25241305  0.41726078  0.32567871  1.90089038\n[217]  0.34399512  1.07665172  0.41726078  1.02170247 -0.07728242  1.24149945  0.69200701  0.45389361\n[225]  0.78358908  0.47221003  0.45389361  0.85685474  0.65537418  1.31476511  0.23409663  0.23409663\n[233]  0.94843681  1.57119492  0.63705776  1.11328455  0.17914739  1.25981586 -0.09559883  1.35139794\n[241]  0.65537418  1.49792926  0.65537418  1.51624567  0.28904588  1.02170247  0.10588173  1.25981586\n[249]  1.00338606  0.54547569  0.82022191  1.31476511  0.83853832  2.19395302  0.60042493  0.94843681\n[257]  0.61874135  0.52715927 -0.40697788  1.73604265 -0.11391525  0.76527266  1.20486662  1.07665172\n[265] -0.07728242  1.38803077  0.41726078  2.04742170  0.10588173  0.89348757  0.60042493          NA\n[273]  0.52715927  1.18655021  0.23409663  1.09496813  0.47221003  1.11328455  1.35139794  0.27072946\n[281]  1.60782775  0.23409663  0.39894437  1.35139794  0.38062795  1.35139794  0.49052644  1.42466360\n[289]  0.56379210  1.47961284  0.36231154  1.20486662  1.16823379  2.57859773  0.45389361  0.96675323\n[297] -0.27876298  0.83853832 -0.13223166  1.22318303  0.50884286  1.47961284  1.20486662  1.02170247\n[305]  0.45389361  1.62614416 -0.55350920  1.88257397 -0.26044656  1.29644869  1.05833530  0.65537418\n[313]  0.67369059  1.47961284  0.54547569  1.75435906  0.93012040  0.41726078  1.27813228  0.28904588\n[321]  1.27813228  1.25981586  1.13160096  0.93012040  1.38803077  1.07665172  0.76527266  1.36971435\n[329]  0.32567871  1.24149945 -0.26044656  1.51624567  0.23409663  0.98506964  1.14991738  0.30736229\n[337]  1.46129643  0.52715927  0.32567871  2.17563660 -0.07728242  1.04001889  1.25981586  1.14991738\n```\n\n\n:::\n:::\n\n\n## Your turn\n\nSee if you can add another argument to `to_z()` to allow the user to specify\nif `NA` values should be removed or not. Give it a default value.\n\n## Your turn\n\nCreate a function called `percent_diff` that calculates the percent difference between two (vectors of)\nvalues:\n\n$$\\%diff = \\frac{|a - b|}{((a + b)/2)} * 100$$\n\n* Hint: you can use the `abs()` function to calculate the absolute value.\n\n## Your turn\n\nCreate a function called `is_big()` that takes a numeric vector and outputs a logical vector indicating whether each value is larger than a specified quantile threshold.\n\n- The function should have two arguments: the numeric vector and the quantile threshold (default to 0.75).\n\n## Types of function\n\n1.  vector functions: one or more vectors as input, one vector as output\n\n    i.  âœ”ï¸ output same length as input.\n\n    **ii. âž¡ï¸ summary functions: input is vector, output is a single\n    value**\n\n2.  data frame functions: df as input and df as output\n\n## Summary functions\n\n-   input is vector\n-   output is a single value\n-   could be used in `summarise()`\n\n## Example\n\nWrite a function to compute the standard error of a sample.\n\n$$s.e. = \\frac{s.d.}{\\sqrt{n}}$$\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd_error <- function(x) {\n  sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))\n}\n```\n:::\n\n\n. . .\n\nNote: `sum(TRUE)` = 1 and `sum(FALSE)` = 0 Thus,`sum(!is.na(x))` gives\nyou the number of `TRUE` (i.e., the number of non-NA values) and is a\nbit shorter than `length(x[!is.na(x)])`\n\n## Try it out\n\nCall the function on `penguins$bill_len`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd_error(penguins$bill_len)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2952205\n```\n\n\n:::\n:::\n\n\n. . .\n\nOr in a pipeline\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  group_by(species) |>\n  summarise(se = std_error(bill_len))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n  species      se\n  <fct>     <dbl>\n1 Adelie    0.217\n2 Chinstrap 0.405\n3 Gentoo    0.278\n```\n\n\n:::\n:::\n\n\n## Your turn\n\nWrite a function to compute the sums of squares (sum of the squared\ndeviations from the mean). This can be calculated with either:\n\n$$SS(x) = \\sum{(x - \\bar{x})^2}$$\n\nor\n\n$$SS(x) = s^2 * (n-1)$$\n\n## A solution - one option\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_sq <- function(x) {\n  sum((x - mean(x, na.rm = TRUE))^2, na.rm = TRUE)\n}\n```\n:::\n\n\nOR\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_sq2 <- function(x) {\n  var_x <- var(x, na.rm = TRUE)\n  n <- sum(!is.na(x))\n  var_x * (n - 1)\n}\n```\n:::\n\n\n. . .\n\nTry it out\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_sq(penguins$bill_len)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10164.21\n```\n\n\n:::\n\n```{.r .cell-code}\nsum_sq2(penguins$bill_len)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10164.21\n```\n\n\n:::\n:::\n\n\n## Types of function\n\nWe will cover two types of function\n\n1.  vector functions: one or more vectors as input, one vector as output\n\n    i.  âœ”ï¸ output same length as input.\n\n    ii. âœ”ï¸ summary functions: input is vector, output is a single value\n\n**2. âž¡ï¸ data frame functions: df as input and df as output**\n\n# Dataframe functions\n\n## Dataframe functions\n\nDataframe as input and Dataframe as output\n\n. . .\n\nFor example, we might summarise one of our columns like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  summarise(\n    mean = mean(bill_len, na.rm = TRUE),\n    n = sum(!is.na(bill_len)),\n    sd = sd(bill_len, na.rm = TRUE),\n    se = std_error(bill_len)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      mean   n       sd        se\n1 43.92193 342 5.459584 0.2952205\n```\n\n\n:::\n:::\n\n\nOutput is a dataframe\n\n## Dataframe functions\n\nGood candidate for a function to avoid repetitive code: `my_summary()`\n\n## Define `my_summary()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_summary <- function(df, column) {\n  df |>\n    summarise(\n      mean = mean(column, na.rm = TRUE),\n      n = sum(!is.na(column)),\n      sd = sd(column, na.rm = TRUE),\n      se = std_error(column)\n    )\n}\n```\n:::\n\n\n## Use function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_summary(penguins, bill_len)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `summarise()`:\nâ„¹ In argument: `mean = mean(column, na.rm = TRUE)`.\nCaused by error:\n! object 'bill_len' not found\n```\n\n\n:::\n:::\n\n\nðŸ˜•\n\n## Tidy evaluation\n\n`tidyverse` functions like `dplyr::summarise()` use \"tidy evaluation\" so\nyou can refer to the names of variables inside dataframes. For example,\nyou can use:\n\neither\n\n``` r\npenguins |> summarise(mean = mean(bill_dep))\n```\n\nOr\n\n``` r\nsummarise(penguins, mean = mean(bill_dep))\n```\n\n## Tidy evaluation\n\nThis is instead of having to use the full dataframe name with `$`, e.g.\n\n``` r\nsummarise(penguins, mean = mean(penguins$bill_dep))\n```\n\n. . .\n\nThis is known as data-masking: the dataframe environment *masks* the\nuser environment by giving priority to the dataframe.\n\n## Data masking is great....\n\nand makes life easier when working interactively\n\n\\\n\n. . .\n\nBut kind of annoying in functions\n\n\\\n\n::: {.columns}\n\n::: {.column width=\"49%\"}\n\n```r\nmy_summary <- function(df, column) {\n  df |>\n    summarise(\n      mean = mean(column, na.rm = TRUE),\n      n = sum(!is.na(column)),\n      sd = sd(column, na.rm = TRUE),\n      se = std_error(column)\n    )\n}\n```\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\nBecause of data-masking, `summarise()` in `my_summary()` is looking for\na column *literally* called `column` in the dataframe that has been\npassed in. It is not looking *inside* the variable `column` for the name\nof column you want to give it.\n\n::: \n\n:::\n\n. . .\n\nRead more: [Programming with\ndplyr](https://dplyr.tidyverse.org/articles/programming.html)\n\n## Fix `my_summary()` function\n\nThe solution is to use embracing: `{{{ var }}}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_summary <- function(df, column) {\n  df |>\n    summarise(\n      mean = mean({{ column }}, na.rm = TRUE),\n      n = sum(!is.na({{ column }})),\n      sd = sd({{ column }}, na.rm = TRUE),\n      se = std_error({{ column }})\n    )\n}\n```\n:::\n\n\n. . .\n\n-   tells `summarize()` to look inside `column` variable to get the column name\n-   style with spaces\n-   `.groups = \"drop\"` to avoid message and leave the data in an\n    ungrouped state\n\n## Use function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_summary(penguins, bill_len)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      mean   n       sd        se\n1 43.92193 342 5.459584 0.2952205\n```\n\n\n:::\n:::\n\n\nðŸŽ‰\n\n## When to embrace?\n\nWhen tidy evaluation is used\n\n## Your turn\n\nWrite a new summary function which calculates the median, maximum and\nminimum values of a variable in a dataset. Incorporate an argument to allow the\nsummary to be performed grouped by another variable.\n\n## Your turn\n\nTry it out\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_summary(penguins, bill_len, species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 4\n  species   median minimum maximum\n  <fct>      <dbl>   <dbl>   <dbl>\n1 Adelie      38.8    32.1    46  \n2 Chinstrap   49.6    40.9    58  \n3 Gentoo      47.3    40.9    59.6\n```\n\n\n:::\n:::\n\n\n## Your turn\n\nImprovement: Have a default of `NULL` for the grouping variable. Why?\n\n## Your turn\n\nTry it out\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_summary(penguins, bill_len)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 3\n  median minimum maximum\n   <dbl>   <dbl>   <dbl>\n1   44.4    32.1    59.6\n```\n\n\n:::\n:::\n\n\n## Your turn\n\nTry it out with more than one group\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nmy_summary(penguins, bill_len, c(species, island))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `group_by()`:\nâ„¹ In argument: `c(species, island)`.\nCaused by error:\n! `c(species, island)` must be size 344 or 1, not 688.\n```\n\n\n:::\n:::\n\n\n. . . \n\nðŸ˜•\n\n::: {.notes}\nBy using embracing in this way, it is actually trying to group by the contents of the two columns concatenated, not the two columns separately.\n:::\n\n## A solution\n\nUse `pick()` which allows you to select a subset of columns inside a\ndata masking function:\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|3\"}\nmy_summary <- function(df, summary_var, group_var = NULL) {\n  df |>\n    group_by(pick({{ group_var }})) |>\n    summarise(\n      median = median({{ summary_var }}, na.rm = TRUE),\n      minimum = min({{ summary_var }}, na.rm = TRUE),\n      maximum = max({{ summary_var }}, na.rm = TRUE),\n      .groups = \"drop\"\n    )\n}\n```\n:::\n\n\n## \n\nTry it out with more than one group\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_summary(penguins, bill_len, c(species, island))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 5\n  species   island    median minimum maximum\n  <fct>     <fct>      <dbl>   <dbl>   <dbl>\n1 Adelie    Biscoe      38.7    34.5    45.6\n2 Adelie    Dream       38.6    32.1    44.1\n3 Adelie    Torgersen   38.9    33.5    46  \n4 Chinstrap Dream       49.6    40.9    58  \n5 Gentoo    Biscoe      47.3    40.9    59.6\n```\n\n\n:::\n:::\n\n\n## Functions - data validation and error handling\n\nIt's good practice to include data validation and error handling in your functions to ensure they behave as expected when given incorrect or unexpected inputs.\n\n- Use `stop()` to throw an **`Error`** if issues are serious enough that it should not proceed.\n- Use `warning()` to issue a **`Warning`** for non-critical issues.\n\n\n::: {.columns}\n\n::: {.column}\n\n### Errors\n\n```r\nif (some_condition_not_met) {\n  stop(\"Descriptive error message.\")\n\t# Function exits and does not return a result\n}\n```\n\n::: \n\n::: {.column}\n\n::: {.fragment}\n\n### Warnings\n\n```r\nif (some_non_critical_condition) {\n  warning(\"Descriptive warning message.\")\n\t# Function continues executing\n}\n```\t\n\n:::\n\n::: \n\n:::\n\n## Example\n\nIf a function expects two numeric vectors of the same length, you should check\nand stop the if they are not.\n\n::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent_diff <- function(x, y) {\n  (abs(x - y) /\n    ((x + y) / 2)) *\n    100\n}\n```\n:::\n\n\n:::\n\n::: {.column}\n\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent_diff <- function(x, y) {\n  if (length(x) != length(y)) {\n    stop(\"Input vectors must be of the same length.\")\n  }\n\n  (abs(x - y) /\n    ((x + y) / 2)) *\n    100\n}\n```\n:::\n\n\n:::\n\n\\\n\n::: {.fragment}\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\na <- c(1, 2, 3)\nb <- c(4, 5)\n\npercent_diff(a, b)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in percent_diff(a, b): Input vectors must be of the same length.\n```\n\n\n:::\n:::\n\n\n:::\n:::\n:::\n\n## Your turn\n\n1. Add a check to `my_summary()` to ensure that the `summary_var` is numeric. If not, throw an error.\n\n2. Add a warning to `to_z()` if the input vector has fewer than 3 non-NA values, since the standard deviation may not be meaningful in that case.\n\n## Summary â˜•\n\n-   Writing functions can make you more efficient and make your code\n    more readable. This can be just for your benefit.\n\n-   Vector functions take one or more vectors as input; their output can\n    be a vector (useful in `mutate()` and `filter()`) or a single value\n    (useful in `summarise()`).\n\n-   Dataframe functions take a dataframe as input and give a dataframe\n    as output\n\n-   Give arguments a default where possible\n\n-   We use `{{ var }}` embracing to manage data masking\n\n-   We use `pick({{ vars }})` to select more than one variable\n\n-   Include data validation and error handling in your functions\n",
    "supporting": [
      "programming-functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}