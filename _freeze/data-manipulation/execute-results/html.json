{
  "hash": "a6ca3182b9b0c599adc849c86b22938f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced Data Manipulation with `dplyr` and `tidyr`\"\nsubtitle: \"Parks Canada; Ecological Integrity Monitoring Program\"\nauthor: \"Andy Teucher\"\nformat: revealjs\nknitr:\n  opts_chunk: \n    R.options:\n      width: 120\n---\n\n\n\n## Outline\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\nToday:\n\n- `dplyr` fundamentals review\n- Column-wise operations\n- Two-table verbs (joins)\n\n:::\n::: {.column width=\"50%\"}\n\nNext time:\n\n- Window functions\n- Row-wise operations\n- Data reshaping with `tidyr`\n\n:::\n:::\n\n## Data\n\n### Using data from the [Portal Project](https://portal.weecology.org/)\n\nLong-term ecological research site studying the dynamics of desert rodents, plants, ants and weather in Arizona.\n\nData available from the [GitHub repo](https://github.com/weecology/PortalData) via the [`portalr`](https://github.com/weecology/portalr) package.\n\n## Setup\n\n1. Create a new project in Positron\n\n- Either: \n\t- Fork and clone the exercises repository:  \n\t `https://github.com/ateucher/pc-data-manipulation/` OR \n\t- Run:\n\t ```r\n\t usethis::use_course(\"https://github.com/ateucher/pc-data-manipulation/archive/refs/heads/main.zip\")\n\t ```\n\n2. Open the file: `01-get-data.R`\n\n3. Download the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"portalr\")\nlibrary(portalr)\n\ndownload_observations(\".\")\n```\n:::\n\n\n4. Explore the downloaded data in Positron\n\n\n## Review of main `dplyr` operations\n\n- Selecting columns with `select()`\n- Filtering rows with `filter()`\n- \"Slice\" rows with `slice()`/`slice_*()`\n- Creating new columns with `mutate()`\n- Summarizing data with `summarize()`\n\n::: {.fragment}\n- Grouping data with `group_by()` applies `filter()`, `mutate()`, and `summarize()` by group\n:::\n\n## Warm-up\n\nRead in the rodent capture data (`PortalData/Rodents/Portal_rodent.csv`). \n\n1. Use `readr::read_csv()` and assign it to a data frame called `rodents`.\n2. Standardize column names to use `snake_case` *(hint: check out the `janitor` package)*\n\n## `dplyr` practice\n\n::::: {.columns}\n::: {.column width=\"68%\"}\n\n1. Remove records from invalid sampling periods (when `period` is negative). Re-assign the result to the `rodents` data frame.\n\n2. How many individuals of each species were caught in 1995?\n\n3. What date had the highest number of individual rodents caught?\n\n:::\n\n:::: {.column width=\"30%\"}\n::: {style=\"padding-left: 1em; border-left: 1px solid #ccc;\"}\n\n**Key columns**\n\n- `id` = individual identifier\n- `day`, `month`, `year` = date of capture\n- `period` = sampling period\n- `species` = species code\n- `wgt` = weight (grams)\n- `year` = year of capture\n\n:::\n::::\n:::::\n\n## `dplyr` practice\n\n::::: {.columns}\n::: {.column width=\"68%\"}\n\n4. For each capture record, calculate the percent difference in weight from the average weight of that species.\n\n5. Of all individual Ord's Kangaroo Rats (species code \"DO\") that have been caught more than 5 times, which individual was consistently the biggest? (i.e., has the highest average percent difference in weight from the species' average weight)?\n\n:::\n\n:::: {.column width=\"30%\"}\n::: {style=\"padding-left: 1em; border-left: 1px solid #ccc;\"}\n\n**Key columns**\n\n- `id` = individual identifier\n- `day`, `month`, `year` = date of capture\n- `period` = sampling period\n- `species` = species code\n- `wgt` = weight (grams)\n- `year` = year of capture\n\n:::\n::::\n:::::\n\n## Column-wise operations\n\n- Apply one or more functions to a set of columns in a data frame using `across()`\n- Specfiy columns using [selection helpers](https://tidyselect.r-lib.org/reference/language.html) (e.g., `starts_with()`, `ends_with()`, `contains()`, `where()`, etc.)\n- Specify function(s) to apply to selected columns\n- Used with `summarize()` & `mutate()`\n\n::: {.fragment}\n\n#### Example: calculate mean of all numeric columns\n\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\nmtcars |>\n  group_by(cyl) |>\n  summarize(across(where(is.numeric), mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 11\n    cyl   mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     4  26.7  105.  82.6  4.07  2.29  19.1 0.909 0.727  4.09  1.55\n2     6  19.7  183. 122.   3.59  3.12  18.0 0.571 0.429  3.86  3.43\n3     8  15.1  353. 209.   3.23  4.00  16.8 0     0.143  3.29  3.5 \n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.notes}\nWe are passing the function `mean` to `across()`, not calling it (i.e., no parentheses).\nFunctions in R are objects that can be passed around and used later.\n:::\n\n## Column-wise operations\n\nspecify multiple functions to apply in a `list()`\n\n<br>\n\n::: {.fragment}\n\n#### Example: calculate mean and sd of all numeric columns\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\nmtcars |>\n  group_by(cyl) |>\n  summarize(\n    across(where(is.numeric), list(mean = mean, sd = sd))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 21\n    cyl mpg_mean mpg_sd disp_mean disp_sd hp_mean hp_sd drat_mean drat_sd wt_mean wt_sd qsec_mean qsec_sd vs_mean vs_sd\n  <dbl>    <dbl>  <dbl>     <dbl>   <dbl>   <dbl> <dbl>     <dbl>   <dbl>   <dbl> <dbl>     <dbl>   <dbl>   <dbl> <dbl>\n1     4     26.7   4.51      105.    26.9    82.6  20.9      4.07   0.365    2.29 0.570      19.1    1.68   0.909 0.302\n2     6     19.7   1.45      183.    41.6   122.   24.3      3.59   0.476    3.12 0.356      18.0    1.71   0.571 0.535\n3     8     15.1   2.56      353.    67.8   209.   51.0      3.23   0.372    4.00 0.759      16.8    1.20   0     0    \n# ℹ 6 more variables: am_mean <dbl>, am_sd <dbl>, gear_mean <dbl>, gear_sd <dbl>, carb_mean <dbl>, carb_sd <dbl>\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.resources}\n\n<https://tidyselect.r-lib.org/reference/language.html>\n\n:::\n\n## Column-wise operations\n\nRun this in your R session, what do you get?\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\npenguins |>\n  summarize(\n    across(where(is.numeric), list(mean = mean, sd = sd))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  bill_len_mean bill_len_sd bill_dep_mean bill_dep_sd flipper_len_mean flipper_len_sd body_mass_mean body_mass_sd\n          <dbl>       <dbl>         <dbl>       <dbl>            <dbl>          <dbl>          <dbl>        <dbl>\n1            NA          NA            NA          NA               NA             NA             NA           NA\n# ℹ 2 more variables: year_mean <dbl>, year_sd <dbl>\n```\n\n\n:::\n:::\n\n\n<br>\n\n::: {.fragment}\n\n- When we pass a function to `across()` it is passed with its default arguments\n\t- `mean()` and `sd()` both have an argument `na.rm` that defaults to `FALSE`\n- We can't pass extra arguments to functions inside `across()` directly\n- We need to pass a function with the argument values we want \"baked in\"\n\n:::\n\n::: {.resources}\n\n<https://tidyselect.r-lib.org/reference/language.html>\n\n:::\n\n## Specifying extra arguments\n\nWe can define our own helper functions:\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nsd_na <- function(x) {\n  sd(x, na.rm = TRUE)\n}\n\nmean_na <- function(x) {\n  mean(x, na.rm = TRUE)\n}\n\npenguins |>\n  summarize(\n    across(where(is.numeric), list(mean = mean_na, sd = sd_na))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  bill_len_mean bill_len_sd bill_dep_mean bill_dep_sd flipper_len_mean flipper_len_sd body_mass_mean body_mass_sd\n          <dbl>       <dbl>         <dbl>       <dbl>            <dbl>          <dbl>          <dbl>        <dbl>\n1          43.9        5.46          17.2        1.97             201.           14.1          4202.         802.\n# ℹ 2 more variables: year_mean <dbl>, year_sd <dbl>\n```\n\n\n:::\n:::\n\n\n## Specifying extra arguments\n\nBut if we're doing this only once we can define them in place with an [anonymous function]{.highlight-term}:\n\n```r\n\\(x) function(x, other_args)\n```\n\n- This defines a function \"on the fly\" with the arguments specified how we want\n- The `x` will take the values of each column passed to it by `across()`\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\npenguins |>\n  summarize(\n    across(\n      where(is.numeric),\n      list(\n        mean = \\(x) mean(x, na.rm = TRUE),\n        sd = \\(x) sd(x, na.rm = TRUE)\n      )\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  bill_len_mean bill_len_sd bill_dep_mean bill_dep_sd flipper_len_mean flipper_len_sd body_mass_mean body_mass_sd\n          <dbl>       <dbl>         <dbl>       <dbl>            <dbl>          <dbl>          <dbl>        <dbl>\n1          43.9        5.46          17.2        1.97             201.           14.1          4202.         802.\n# ℹ 2 more variables: year_mean <dbl>, year_sd <dbl>\n```\n\n\n:::\n:::\n\n\n\n## Your turn\n\n1. Calculate the median of both types of bill measurements for each species in the built-in `penguins` dataset\n\n2. Round all of the numeric colums in the `PortalData/SiteandMethods/Portal_UTMCoords.csv` dataset to 2 decimal places\n\n## Two-table verbs (joins)\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n![](img/tables-join-1.png){.absolute width=540px left=80px top=225px}\n\n:::\n\n::: {.column width=\"50%\"}\n\n### Mutatating joins\n\n- Combine two tables based on common values in one or more columns\n\n### Filtering joins\n\n- Filter rows from one table based on values in another table\n\n::: \n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `left_join()`\n\n- Keeps all rows in the [left]{.highlight-term} table\n- Drops rows from the [right]{.highlight-term} table that don't match\n- Rows in the [left]{.highlight-term} that don't match get `NA` in the columns from the [right]{.highlight-term} table\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/left-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `right_join()`\n\n- Keeps all rows in the [right]{.highlight-term} table\n- Drops rows from the [left]{.highlight-term} table that don't match\n- Rows in the [right]{.highlight-term} table that don't match get `NA` in the columns from the [left]{.highlight-term} table\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/right-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `inner_join()`\n\n- Keeps all rows in both tables where keys match\n- Rows from either table that don't match are dropped\n\n:::\n::: {.column width=\"50%\"}\n\n![](img/inner-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `full_join()`\n\n- Keeps all rows in both tables\n- Values in x and y that don't match get `NA` in the result\n\n:::\n::: {.column width=\"50%\"}\n\n![](img/full-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Join syntax\n\nIf don't specify join columns, will join on all common names\n\n- E.g., both tables have columns year, month, day\n\n```r\nleft_join(x, y)\n#> Joining with `by = join_by(year, month, day)`\n```\n\n<br>\n\nBetter to specify the join columns explicitly\n\n- Both tables have columns column_1 and column_2\n\n```r\nleft_join(x, y, by = c(\"column_1\", \"column_2\"))\n```\n\n\n- If the columns to join on have different names in each table\n\n```r\nleft_join(x, y, by = c(\"column_in_x\" = \"column_in_y\"))\n```\n\n## Your turn\n\nUse a join to add location information to the rodent captures data\n\n- The rodent captures data is in the `PortalData/Rodents/Portal_rodent.csv` file.\n\n- The `SiteandMethods/Portal_UTMCoords.csv` file contains information about the location of each plot\n\n## Filtering joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `semi_join()`\n\n- Keeps all rows in the [left]{.highlight-term} table where there are matching key values in the [right]{.highlight-term} table\n- Does not add any columns\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/semi-join.png)\n\n:::\n:::\n\n\n## Filtering joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `anti_join()`\n\n- Keeps all rows in the [left]{.highlight-term} table where there are not matching values in the [right]{.highlight-term} table\n- Does not add any columns\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/anti-join.png)\n\n:::\n:::\n\n## Your turn\n\nUse a join to find all the captures where the species is a granivore\n\n- The rodent captures data is in the `PortalData/Rodents/Portal_rodent.csv` file\n- The `PortalData/Rodents/Portal_rodent_species.csv` file contains information about the species\n\n## More complex joins using `dplyr::join_by()`. \n\n**Cross joins** create the full cartesian product of two tables\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\nx <- data.frame(a = 1:3)\ny <- data.frame(b = c(\"x\", \"y\"))\ncross_join(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a b\n1 1 x\n2 1 y\n3 2 x\n4 2 y\n5 3 x\n6 3 y\n```\n\n\n:::\n:::\n\n\n<br>\n\n::: {.fragment}\n\nInequality joins\n\n```r\nleft_join(x, y, by = join_by(column_1 >= column_2))\n```\n\n:::\n\n<br>\n\n::: {.fragment}\n\nRolling joins (inequality joins constrained by `closest()`)\n\n```r\nleft_join(\n    x, y, \n    by = join_by(id, closest(capture_date >= survey_start_date))\n)\n```\n\nRolling joins are good for finding things like \"the most recent rainy day before a survey date\"\n\n:::\n\n\n::: {.notes}\nI haven't found a good reason to use inequality joins, but they are a necessary \nprecursor to rolling joins, which are very useful.\n:::\n\n\n## Overlap joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n```r\nbetween(x, y_1, y_2)\nwithin(x_1, x_2, y_1, y_2)\noverlaps(x_1, x_2, y_1, y_2)\n```\n\n:::\n::: {.column width=\"50%\"}\n\n```{.plaintext .cell-output-tall}\nbetween(x, y_1, y_2):\n\n  y_1 [════════════════════] y_2\n         •\n         x\n\n\nwithin(x_1, x_2, y_1, y_2):\n\n  y_1 [════════════════════] y_2\n         [═════]\n       x_1     x_2\n\n\noverlaps(x_1, x_2, y_1, y_2):\n\n  y_1 [════════════════════] y_2\n                   [═══════════════] \n                 x_1             x_2\n```\n:::\n:::\n\n::: {.resources}\n\n<https://dplyr.tidyverse.org/reference/join_by.html#join-types>\n\n:::\n\n## Your turn\n\nUsing the rodent trapping data and the plant census dates data, join the two \ndatasets to find out which plant census (year and season) each rodent capture \nis associated with.\n\nStarting code:\n\n```r\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\nplant_census_dates <- read_csv(\n  \"PortalData/Plants/Portal_plant_census_dates.csv\",\n  na = c(\"unknown\", \"none\")\n)\n\nrodent_trapping <- read_csv(\"PortalData/Rodents/Portal_rodent_trapping.csv\")\n```\n\n* Hint: use an overlap join with `between()`\n\n# Window functions\n\n# Row-wise operations\n\n# `tidyr`\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}