{
  "hash": "0f0d8212b5643f49dd4cead7b27d0733",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced Data Manipulation with `dplyr` and `tidyr`\"\nsubtitle: \"Parks Canada; Ecological Integrity Monitoring Program\"\nauthor: \"Andy Teucher\"\nformat: revealjs\nknitr:\n  opts_chunk: \n    R.options:\n      width: 110\n      pillar.print_max: 5\n      pillar.print_min: 5\n    echo: true\n---\n\n\n\n## Outline\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\nToday:\n\n- `dplyr` fundamentals review\n- Column-wise operations\n- Two-table verbs (joins)\n- Data reshaping with `tidyr`\n- Window functions?\n\n:::\n:::\n\n## Data\n\n### Using data from the [Portal Project](https://portal.weecology.org/)\n\nLong-term ecological research site studying the dynamics of desert rodents, plants, ants and weather in Arizona.\n\nData available from the [GitHub repo](https://github.com/weecology/PortalData) via the [`portalr`](https://github.com/weecology/portalr) package.\n\n## Setup\n\n1. Create a new project in Positron\n\n- Either: \n\t- Fork and clone the exercises repository:  \n\t `https://github.com/ateucher/pc-data-manipulation/` OR \n\t- Run:\n\t ```r\n\t usethis::use_course(\"https://github.com/ateucher/pc-data-manipulation/archive/refs/heads/main.zip\")\n\t ```\n\n2. Open the file: `01-get-data.R`\n\n3. Download the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"portalr\")\nlibrary(portalr)\n\ndownload_observations(\".\")\n```\n:::\n\n\n4. Explore the downloaded data in Positron\n\n## Warm-up\n\nRead in the rodent capture data (`PortalData/Rodents/Portal_rodent.csv`). \n\n1. Use `readr::read_csv()` and assign it to a data frame called `rodents`.\n2. Standardize column names to use `snake_case` *(hint: check out the `janitor` package)*\n\n## Review of main `dplyr` operations\n\n- Select columns with `select()`\n- Keep rows based on their values with `filter()`\n- Create new columns with `mutate()`\n- Summarize data with `summarize()`\n- Sort rows based on column values with `arrange()`\n- \"Slice\" rows with `slice()`/`slice_*()`\n\n::: {.fragment}\n- Grouping data with `group_by()` applies `filter()`, `mutate()`, `summarize()`, and `slice()` by group\n:::\n\n## Using `select()`\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### Select columns with bare names\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\npenguins |>\n  select(species, island, body_mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 3\n  species island    body_mass\n  <fct>   <fct>         <int>\n1 Adelie  Torgersen      3750\n2 Adelie  Torgersen      3800\n3 Adelie  Torgersen      3250\n4 Adelie  Torgersen        NA\n5 Adelie  Torgersen      3450\n# ℹ 339 more rows\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\n### Use `all_of()` or `any_of()` to select columns from a character vector\n\n- `all_of()`: throws an error if any names are not found\n- `any_of()`: ignores names that are not found\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ncols <- c(\"species\", \"sex\", \"bill_len\", \"bill_dep\")\nselect(penguins, all_of(cols))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 4\n  species sex    bill_len bill_dep\n  <fct>   <fct>     <dbl>    <dbl>\n1 Adelie  male       39.1     18.7\n2 Adelie  female     39.5     17.4\n3 Adelie  female     40.3     18  \n4 Adelie  <NA>       NA       NA  \n5 Adelie  female     36.7     19.3\n# ℹ 339 more rows\n```\n\n\n:::\n:::\n\n\n:::\n:::\n:::\n\n::: {.question .fragment}\n[Your turn:]{.color-yellow} Select record_id, id, and species from rodents\n:::\n\n## selection helpers\n\n::: {.columns}\n::: {.column width=\"50%\"}\n### select _specific columns_:\n\n- `everything()`: Matches all variables.\n- `last_col()`: Select last variable, possibly with an offset.\n- `group_cols()`: Select all grouping columns.\n\n:::\n::: {.column width=\"50%\"}\n\n### select columns based on _name patterns_:\n\n- `starts_with()`: Starts with a prefix.\n- `ends_with()`: Ends with a suffix.\n- `contains()`: Contains a literal string.\n- `matches()`: Matches a regular expression.\n\n### select columns based on _data type_:\n\n- `where()`: Select columns based on a predicate function (a function that returns `TRUE` or `FALSE`).\n\n:::\n:::\n\nSee help with `?select`\n\n::: {.notes}\n\n- `everything()` is useful when you want to move a column to the front or back of the data frame.\n- Selection helpers can be combined using `c()`, e.g., `select(df, c(starts_with(\"temp\"), ends_with(\"date\")))`\n\n:::\n\n## Your turn\n\n### Using the `rodents` data.frame:\n\n- Select the `id` column and all of the numeric columns\n\n- Select all columns except the columns starting with `\"note\"`\n\n- Reorder the columns, moving the last column to the first position, without specifying any column names\n\n## Using `filter()`\n\nTo retain only a subset of rows:\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(penguins, species == \"Adelie\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 152 × 8\n  species island    bill_len bill_dep flipper_len body_mass sex     year\n  <fct>   <fct>        <dbl>    <dbl>       <int>     <int> <fct>  <int>\n1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n4 Adelie  Torgersen     NA       NA            NA        NA <NA>    2007\n5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n# ℹ 147 more rows\n```\n\n\n:::\n:::\n\n\n## Combine multiple `filter()` conditions with `,` or `&` (AND) and `|` (OR):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(penguins, species == \"Adelie\", island == \"Torgersen\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52 × 8\n  species island    bill_len bill_dep flipper_len body_mass sex     year\n  <fct>   <fct>        <dbl>    <dbl>       <int>     <int> <fct>  <int>\n1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n4 Adelie  Torgersen     NA       NA            NA        NA <NA>    2007\n5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n# ℹ 47 more rows\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(penguins, species == \"Adelie\" | (species == \"Gentoo\" & body_mass < 4000))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 153 × 8\n  species island    bill_len bill_dep flipper_len body_mass sex     year\n  <fct>   <fct>        <dbl>    <dbl>       <int>     <int> <fct>  <int>\n1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n4 Adelie  Torgersen     NA       NA            NA        NA <NA>    2007\n5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n# ℹ 148 more rows\n```\n\n\n:::\n:::\n\n\n::: {.notes}\n\nlive code these\n\n:::\n\n## Using `mutate()`\n\nCreate new columns or modify existing columns:\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(penguins, mass_kg = body_mass / 1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 9\n  species island    bill_len bill_dep flipper_len body_mass sex     year mass_kg\n  <fct>   <fct>        <dbl>    <dbl>       <int>     <int> <fct>  <int>   <dbl>\n1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007    3.75\n2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007    3.8 \n3 Adelie  Torgersen     40.3     18           195      3250 female  2007    3.25\n4 Adelie  Torgersen     NA       NA            NA        NA <NA>    2007   NA   \n5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007    3.45\n# ℹ 339 more rows\n```\n\n\n:::\n:::\n\n\n::: {.fragment}\nCreate multiple columns in one mutate call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  penguins,\n  mass_kg = body_mass / 1000,\n  bill_ratio = bill_len / bill_dep\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 344 × 10\n  species island    bill_len bill_dep flipper_len body_mass sex     year mass_kg bill_ratio\n  <fct>   <fct>        <dbl>    <dbl>       <int>     <int> <fct>  <int>   <dbl>      <dbl>\n1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007    3.75       2.09\n2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007    3.8        2.27\n3 Adelie  Torgersen     40.3     18           195      3250 female  2007    3.25       2.24\n4 Adelie  Torgersen     NA       NA            NA        NA <NA>    2007   NA         NA   \n5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007    3.45       1.90\n# ℹ 339 more rows\n```\n\n\n:::\n:::\n\n:::\n\n::: {.notes}\n\nlive code these\n\n:::\n\n## The pipe ( |> )\n\nThe pipe operator (`|>`) passes the output of one function as the first argument to the next function.\nIt allows us to chain together multiple operations in a readable way.\n\n::: {.fragment}\n- Helps avoid deeply nested function calls, which are hard to read.\n\n```r\nfilter(select(penguins, species, island, body_mass), body_mass > 4000)\n```\n:::\n\n::: {.fragment}\n\n- Helps avoid creating many intermediate variables.\n\n```r\nselected_data <- select(penguins, species, island, body_mass)\nfiltered_data <- filter(selected_data, body_mass > 4000)\n```\n:::\n\n::: {.fragment}\n\nRead it out loud as _\"and then\"_\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> # and then\n  select(species, island, body_mass) |> # and then\n  filter(body_mass > 4000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 172 × 3\n  species island    body_mass\n  <fct>   <fct>         <int>\n1 Adelie  Torgersen      4675\n2 Adelie  Torgersen      4250\n3 Adelie  Torgersen      4400\n4 Adelie  Torgersen      4500\n5 Adelie  Torgersen      4200\n# ℹ 167 more rows\n```\n\n\n:::\n:::\n\n\n:::\n\n## Using `group_by()`\n\nAdd grouping attributes that tell other `dplyr` functions to operate by group:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(species, island, body_mass) |>\n  filter(body_mass > 4000) |>\n  group_by(species, island)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 172 × 3\n# Groups:   species, island [5]\n  species island    body_mass\n  <fct>   <fct>         <int>\n1 Adelie  Torgersen      4675\n2 Adelie  Torgersen      4250\n3 Adelie  Torgersen      4400\n4 Adelie  Torgersen      4500\n5 Adelie  Torgersen      4200\n# ℹ 167 more rows\n```\n\n\n:::\n:::\n\n\n## Using `summarize()`\n\nCreates one summary row per unique combination of groups:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  select(species, island, body_mass) |>\n  filter(body_mass > 4000) |>\n  group_by(species, island) |>\n  summarise(sd_mass = sd(body_mass, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n# Groups:   species [3]\n  species   island    sd_mass\n  <fct>     <fct>       <dbl>\n1 Adelie    Biscoe       268.\n2 Adelie    Dream        170.\n3 Adelie    Torgersen    191.\n4 Chinstrap Dream        230.\n5 Gentoo    Biscoe       496.\n```\n\n\n:::\n:::\n\n\n## Your turn - pulling it all together\n\nUsing the `rodents` data set find the mean hindfoot length per weight of Merriam's Kangaroo Rats (`\"DM\"`) grouped by `plot` and arranged by thew new hfl per weight column.\n\n## `dplyr` practice\n\n::::: {.columns}\n::: {.column width=\"68%\"}\n\n1. Remove records from invalid sampling periods (when `period` is negative). Re-assign the result to the `rodents` data frame.\n\n2. How many individuals of each species were caught in 1995?\n\n3. What date had the highest number of individual rodents caught?\n\n:::\n\n:::: {.column width=\"30%\"}\n::: {style=\"padding-left: 1em; border-left: 1px solid #ccc;\"}\n\n**Key columns**\n\n- `id` = individual identifier\n- `day`, `month`, `year` = date of capture\n- `period` = sampling period\n- `species` = species code\n- `wgt` = weight (grams)\n- `year` = year of capture\n\n:::\n::::\n:::::\n\n## `dplyr` practice\n\n::::: {.columns}\n::: {.column width=\"68%\"}\n\n4. For each capture record, calculate the percent difference in weight from the average weight of that species.\n\n5. Of all individual Ord's Kangaroo Rats (species code \"DO\") that have been caught more than 5 times, which individual was consistently the biggest? (i.e., has the highest average percent difference in weight from the species' average weight)?\n\n:::\n\n:::: {.column width=\"30%\"}\n::: {style=\"padding-left: 1em; border-left: 1px solid #ccc;\"}\n\n**Key columns**\n\n- `id` = individual identifier\n- `day`, `month`, `year` = date of capture\n- `period` = sampling period\n- `species` = species code\n- `wgt` = weight (grams)\n- `year` = year of capture\n\n:::\n::::\n:::::\n\n## Column-wise operations\n\n<!-- Start here after dplyr fundamentals -->\n\n- Apply one or more functions to a set of columns in a data frame using `across()`\n\n```r\nacross(<columns>, <functions>)\n```\n\n- Specify columns using a _vector of names_ or [selection helpers](https://tidyselect.r-lib.org/reference/language.html) (e.g., `starts_with()`, `ends_with()`, `contains()`, `where()`, etc.)\n- Specify function(s) to apply to selected columns\n- Used with `summarize()` & `mutate()`\n\n::: {.fragment}\n\n#### Example: calculate mean of all numeric columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nmtcars |>\n  group_by(cyl) |>\n  summarize(across(where(is.numeric), mean))\n```\n:::\n\n\n:::\n\n::: {.notes}\nSelection syntax is the same as in `select()`, i.e., using the same selection helpers\n\nWe are passing the function `mean` to `across()`, not calling it (i.e., no parentheses).\nFunctions in R are objects that can be passed around and used later.\n:::\n\n## Your turn\n\n- Scale `hfl` and `wgt` (use `across()`) in `rodents` to have mean 0 and standard deviation 1. *(Hint: Check out the `scale()` function)*\n- **Bonus:** Use the `.names` argument to keep the original columns and give the new columns a sensible name\n- See help with `?across`\n\n## Column-wise operations\n\nSpecify _multiple_ functions to apply to selected in a named `list()`\n\n<br>\n\n::: {.fragment}\n\n#### Example: calculate mean and sd of all numeric columns\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\nmtcars |>\n  group_by(cyl) |>\n  summarize(\n    across(where(is.numeric), list(mean = mean, sd = sd))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 21\n    cyl mpg_mean mpg_sd disp_mean disp_sd hp_mean hp_sd drat_mean drat_sd wt_mean wt_sd qsec_mean qsec_sd\n  <dbl>    <dbl>  <dbl>     <dbl>   <dbl>   <dbl> <dbl>     <dbl>   <dbl>   <dbl> <dbl>     <dbl>   <dbl>\n1     4     26.7   4.51      105.    26.9    82.6  20.9      4.07   0.365    2.29 0.570      19.1    1.68\n2     6     19.7   1.45      183.    41.6   122.   24.3      3.59   0.476    3.12 0.356      18.0    1.71\n3     8     15.1   2.56      353.    67.8   209.   51.0      3.23   0.372    4.00 0.759      16.8    1.20\n# ℹ 8 more variables: vs_mean <dbl>, vs_sd <dbl>, am_mean <dbl>, am_sd <dbl>, gear_mean <dbl>, gear_sd <dbl>,\n#   carb_mean <dbl>, carb_sd <dbl>\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.resources}\n\n<https://tidyselect.r-lib.org/reference/language.html>\n\n:::\n\n## Column-wise operations\n\nRun this in your R session, what do you get?\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\npenguins |>\n  summarize(\n    across(where(is.numeric), list(mean = mean, sd = sd))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  bill_len_mean bill_len_sd bill_dep_mean bill_dep_sd flipper_len_mean flipper_len_sd body_mass_mean\n          <dbl>       <dbl>         <dbl>       <dbl>            <dbl>          <dbl>          <dbl>\n1            NA          NA            NA          NA               NA             NA             NA\n# ℹ 3 more variables: body_mass_sd <dbl>, year_mean <dbl>, year_sd <dbl>\n```\n\n\n:::\n:::\n\n\n<br>\n\n::: {.fragment}\n\n- When we use a function in `across()` it is called with its default arguments\n\t- `mean()` and `sd()` both have an argument `na.rm` that defaults to `FALSE`\n- We can't pass extra arguments to functions inside `across()` directly\n- We need to specify a function with the argument values we want \"baked in\"\n\n:::\n\n::: {.resources}\n\n<https://tidyselect.r-lib.org/reference/language.html>\n\n:::\n\n## Specifying extra arguments\n\nWe can define our own helper functions:\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nsd_na <- function(x) {\n  sd(x, na.rm = TRUE)\n}\n\nmean_na <- function(x) {\n  mean(x, na.rm = TRUE)\n}\n\npenguins |>\n  summarize(\n    across(where(is.numeric), list(mean = mean_na, sd = sd_na))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  bill_len_mean bill_len_sd bill_dep_mean bill_dep_sd flipper_len_mean flipper_len_sd body_mass_mean\n          <dbl>       <dbl>         <dbl>       <dbl>            <dbl>          <dbl>          <dbl>\n1          43.9        5.46          17.2        1.97             201.           14.1          4202.\n# ℹ 3 more variables: body_mass_sd <dbl>, year_mean <dbl>, year_sd <dbl>\n```\n\n\n:::\n:::\n\n\n::: {.notes}\n\nLive code this\n\n:::\n\n## Specifying extra arguments\n\nBut if we're doing this only once we can define them in place with an [anonymous function]{.highlight-term}:\n\n```r\n\\(x) function(x, other_args)\n```\n\n- `\\(x)` is shorthand for `function(x)`, used for anonymous functions\n- This defines a function \"on the fly\" with the arguments specified how we want\n- The `x` will take the values of each column passed to it by `across()`\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\npenguins |>\n  summarize(\n    across(\n      where(is.numeric),\n      list(\n        mean = \\(x) mean(x, na.rm = TRUE),\n        sd = \\(x) sd(x, na.rm = TRUE)\n      )\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  bill_len_mean bill_len_sd bill_dep_mean bill_dep_sd flipper_len_mean flipper_len_sd body_mass_mean\n          <dbl>       <dbl>         <dbl>       <dbl>            <dbl>          <dbl>          <dbl>\n1          43.9        5.46          17.2        1.97             201.           14.1          4202.\n# ℹ 3 more variables: body_mass_sd <dbl>, year_mean <dbl>, year_sd <dbl>\n```\n\n\n:::\n:::\n\n\n::: {.notes}\n\nLive code this\n\n:::\n\n## Your turn\n\n1. Calculate maximum of all bill measurements for each species in the built-in penguins dataset.\n2. Calculate the median of hind-foot length (`hfl`) and weight (`wgt`) for each species in `rodents`, ignoring `NA` values.\n\n## Two-table verbs (joins)\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n![](img/tables-join-1.png){.absolute width=540px left=80px top=225px}\n\n:::\n\n::: {.column width=\"50%\"}\n\n### Mutating joins\n\n- Combine two tables based on common values in one or more columns\n\n### Filtering joins\n\n- Filter rows from one table based on values in another table\n\n::: \n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `left_join()`\n\n- Keeps all rows in the [left]{.highlight-term} table\n- Drops rows from the [right]{.highlight-term} table that don't match\n- Rows in the [left]{.highlight-term} that don't match get `NA` in the columns from the [right]{.highlight-term} table\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/left-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `right_join()`\n\n- Keeps all rows in the [right]{.highlight-term} table\n- Drops rows from the [left]{.highlight-term} table that don't match\n- Rows in the [right]{.highlight-term} table that don't match get `NA` in the columns from the [left]{.highlight-term} table\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/right-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `inner_join()`\n\n- Keeps all rows in both tables where keys match\n- Rows from either table that don't match are dropped\n\n:::\n::: {.column width=\"50%\"}\n\n![](img/inner-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Mutating joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `full_join()`\n\n- Keeps all rows in both tables\n- Values in x and y that don't match get `NA` in the result\n\n:::\n::: {.column width=\"50%\"}\n\n![](img/full-join.png)\n\n:::\n:::\n\n::: {.resources}\n\n<https://r4ds.hadley.nz/joins.html#how-do-joins-work>\n\n:::\n\n## Join syntax\n\nIf don't specify join columns, will join on all common names\n\n- E.g., both tables have columns year, month, day\n\n```r\nleft_join(x, y)\n#> Joining with `by = join_by(year, month, day)`\n```\n\n<br>\n\nBetter to specify the join columns explicitly\n\n- Both tables have columns column_1 and column_2\n\n```r\nleft_join(x, y, by = c(\"column_1\", \"column_2\"))\n```\n\n\n- If the columns to join on have different names in each table\n\n```r\nleft_join(x, y, by = c(\"column_in_x\" = \"column_in_y\"))\n```\n\n## Your turn\n\nUse a join to add location information to the rodent captures data\n\n::: {.question}\nWhat kind of join would be appropriate here?\n:::\n\n- The rodent captures data is in the `PortalData/Rodents/Portal_rodent.csv` file.\n\n- The `SiteandMethods/Portal_UTMCoords.csv` file contains information about the location of each plot\n\n## Filtering joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `semi_join()`\n\n- Keeps all rows in the [left]{.highlight-term} table where there are matching key values in the [right]{.highlight-term} table\n- Does not add any columns\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/semi-join.png)\n\n:::\n:::\n\n\n## Filtering joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n### `anti_join()`\n\n- Keeps all rows in the [left]{.highlight-term} table where there are not matching values in the [right]{.highlight-term} table\n- Does not add any columns\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](img/anti-join.png)\n\n:::\n:::\n\n## Your turn\n\nUse a join to find all the captures where the species is a granivore\n\n- The rodent captures data is in the `PortalData/Rodents/Portal_rodent.csv` file\n- The `PortalData/Rodents/Portal_rodent_species.csv` file contains information about the species\n\n## More complex joins using `dplyr::join_by()`. \n\n**Cross joins** create the full cartesian product of two tables\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\nx <- data.frame(a = 1:3)\ny <- data.frame(b = c(\"x\", \"y\"))\ncross_join(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a b\n1 1 x\n2 1 y\n3 2 x\n4 2 y\n5 3 x\n6 3 y\n```\n\n\n:::\n:::\n\n\n\n::: {.fragment}\n\nInequality joins\n\n```r\nleft_join(x, y, by = join_by(column_1 >= column_2))\n```\n\n:::\n\n<br>\n\n::: {.fragment}\n\nRolling joins (inequality joins constrained by `closest()`)\n\n```r\nleft_join(\n    x, y, \n    by = join_by(id, closest(capture_date >= survey_start_date))\n)\n```\n\nRolling joins are good for finding things like \"the most recent rainy day before a survey date\"\n\n:::\n\n\n::: {.notes}\nI haven't found a good reason to use inequality joins, but they are a necessary \nprecursor to rolling joins, which are very useful.\n:::\n\n\n## Overlap joins\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n```r\nbetween(x, y_1, y_2)\nwithin(x_1, x_2, y_1, y_2)\noverlaps(x_1, x_2, y_1, y_2)\n```\n\n:::\n::: {.column width=\"50%\"}\n\n```{.plaintext .cell-output-tall}\nbetween(x, y_1, y_2):\n\n  y_1 [════════════════════] y_2\n         •\n         x\n\n\nwithin(x_1, x_2, y_1, y_2):\n\n  y_1 [════════════════════] y_2\n         [═════]\n       x_1     x_2\n\n\noverlaps(x_1, x_2, y_1, y_2):\n\n  y_1 [════════════════════] y_2\n                   [═══════════════] \n                 x_1             x_2\n```\n:::\n:::\n\n::: {.resources}\n\n<https://dplyr.tidyverse.org/reference/join_by.html#join-types>\n\n:::\n\n## Your turn\n\nUsing the rodent trapping data and the plant census dates data, join the two \ndatasets to find out which plant census (year and season) each rodent capture \nis associated with.\n\nStarting code:\n\n```r\nlibrary(dplyr)\nlibrary(readr)\nlibrary(lubridate)\n\nplant_census_dates <- read_csv(\n  \"PortalData/Plants/Portal_plant_census_dates.csv\",\n  na = c(\"unknown\", \"none\")\n)\n\nrodent_trapping <- read_csv(\"PortalData/Rodents/Portal_rodent_trapping.csv\")\n```\n\n* Hint: use an overlap join with `between()`\n\n# Tidying data with `tidyr`\n\n> “Happy families are all alike; every unhappy family is unhappy in its own way.”\n\n— Leo Tolstoy\n\n<br>\n\n> “Tidy datasets are all alike, but every messy dataset is messy in its own way.”\n\n— Hadley Wickham\n\n## What is tidy data?\n\n1. Each variable is a column; each column is a variable.\n2. Each observation is a row; each row is an observation.\n3. Each value is a cell; each cell is a single value.\n\n![](img/tidy-data-r4ds.png)\n\n## Wide vs. long (tidy) data\n\n- Wide data often has \"data\" stored in the column names\n  - Example: dates, treatment groups, measurement types\n\n::: {.columns}\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| subject| treatment_A| treatment_B|\n|-------:|-----------:|-----------:|\n|       1|           5|           7|\n|       2|           6|           8|\n\n\n:::\n:::\n\n\n<br>\n\n::: {.fragment}\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| subject|treatment | value|\n|-------:|:---------|-----:|\n|       1|A         |     5|\n|       1|B         |     7|\n|       2|A         |     6|\n|       2|B         |     8|\n\n\n:::\n:::\n\n\n:::\n::: \n\n{{< column-divider >}}\n\n::: {.column width=\"49%\"}\n::: {.fragment}\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| id| 20250101| 20250201|\n|--:|--------:|--------:|\n|  1|      150|      165|\n|  2|      125|      118|\n\n\n:::\n:::\n\n\n- Dates are stored in the column names\n- Values are masses (in grams).\n\n:::\n\n::: {.fragment}\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| id|date       | mass|\n|--:|:----------|----:|\n|  1|2025-01-01 |  150|\n|  1|2025-02-01 |  165|\n|  2|2025-01-01 |  125|\n|  2|2025-02-01 |  118|\n\n\n:::\n:::\n\n\n:::\n:::\n::::\n\n::: {.notes}\n\n- Each row has more than one observation (more than one time, place, or subject)\n- Variables split across multiple columns\n  - Eg., what if we wanted to the get the mean mass per subject?\n- Second example - we hopefully have metadata that tells us that the values are masses (in grams)\n\n:::\n\n## Example - billboard data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\nbillboard\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 317 × 79\n  artist      track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8   wk9  wk10  wk11  wk12  wk13\n  <chr>       <chr> <date>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 2 Pac       Baby… 2000-02-26      87    82    72    77    87    94    99    NA    NA    NA    NA    NA    NA\n2 2Ge+her     The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n3 3 Doors Do… Kryp… 2000-04-08      81    70    68    67    66    57    54    53    51    51    51    51    47\n4 3 Doors Do… Loser 2000-10-21      76    76    72    69    67    65    55    59    62    61    61    59    61\n5 504 Boyz    Wobb… 2000-04-15      57    34    25    17    17    31    36    49    53    57    64    70    75\n# ℹ 312 more rows\n# ℹ 63 more variables: wk14 <dbl>, wk15 <dbl>, wk16 <dbl>, wk17 <dbl>, wk18 <dbl>, wk19 <dbl>, wk20 <dbl>,\n#   wk21 <dbl>, wk22 <dbl>, wk23 <dbl>, wk24 <dbl>, wk25 <dbl>, wk26 <dbl>, wk27 <dbl>, wk28 <dbl>,\n#   wk29 <dbl>, wk30 <dbl>, wk31 <dbl>, wk32 <dbl>, wk33 <dbl>, wk34 <dbl>, wk35 <dbl>, wk36 <dbl>,\n#   wk37 <dbl>, wk38 <dbl>, wk39 <dbl>, wk40 <dbl>, wk41 <dbl>, wk42 <dbl>, wk43 <dbl>, wk44 <dbl>,\n#   wk45 <dbl>, wk46 <dbl>, wk47 <dbl>, wk48 <dbl>, wk49 <dbl>, wk50 <dbl>, wk51 <dbl>, wk52 <dbl>,\n#   wk53 <dbl>, wk54 <dbl>, wk55 <dbl>, wk56 <dbl>, wk57 <dbl>, wk58 <dbl>, wk59 <dbl>, wk60 <dbl>, …\n```\n\n\n:::\n:::\n\n\n::: {.question .fragment}\nHow would we plot this data to show how the rank of different songs changed over time?\n:::\n\n::: {.question .fragment}\nWhat shape would this data have in long format?\n:::\n\n## `tidyr::pivot_longer()`\n\nReshape data from wide to long format\n\n::: {.columns}\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|1,2,3,6,7|13|14\"}\npivot_longer(\n  data,\n  cols,\n  ...,\n  cols_vary = \"fastest\",\n  names_to = \"name\",\n  names_prefix = NULL,\n  names_sep = NULL,\n  names_pattern = NULL,\n  names_ptypes = NULL,\n  names_transform = NULL,\n  names_repair = \"check_unique\",\n  values_to = \"value\",\n  values_drop_na = FALSE,\n  values_ptypes = NULL,\n  values_transform = NULL\n)\n```\n:::\n\n\n:::\n\n::: {.column}\n\n- `cols`: columns to pivot from wide to long. Uses tidyselect syntax.\n- `names_to`: name of new column to create from the column names\n- `values_to`: name of new column to create from the values in the selected columns\n- `values_drop_na`: if `TRUE`, drops rows with `NA` in the values column\n\n:::\n\n:::\n\n::: {.question .fragment}\n\nLet's practice with the billboard data\n\n:::\n\n::: {.notes}\n\n- go to R and do pivot_longer() on billboard data\n\n:::\n\n## Your turn\n\n- Use `SitesandMethods/Portal_plot_treatments.csv` and pivot it to longer so there is a start_date, end_date, and treatment column. See if you can get the dates into proper date format. The `lubridate` package may be helpful.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}